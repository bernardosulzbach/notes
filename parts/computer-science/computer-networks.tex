\chapter{Computer networks}

\section{Protocols}

Protocols are relevant to solve heterogeneity.

An \textbf{entity} is any device capable of sending and receiving data.

\textbf{Peers} are entities from the same layer in the receiver and sender.

The \textbf{protocol stack} is the set of protocols used by a system.

\subsection{Types of standard}

\href{https://en.wikipedia.org/wiki/De_facto_standard}{\emph{De facto}
standards} are standards which are actually in use. \emph{De jure}
standards are recognized by a committee.

\section{OSI model}

The \href{https://en.wikipedia.org/wiki/OSI_model}{OSI model} has seven layers. It doesn't specify anything about their implementation.

\section{Transmission medium}

The \textbf{bandwidth of a channel} is the range of frequencies that is passed by it.
One can show that that the rate at which pulses can be transmitted over a channel is proportional to the bandwidth according to \cite{communication-networks-leon-garcia-2000}.

\subsection{Media layers}

\begin{enumerate}
\item \textbf{Physical}. Transmission and reception of raw bit streams over a physical medium.
\item \textbf{Data link}. Reliable transmission of data frames between two nodes connected by a physical layer.
\item \textbf{Network}. Structuring and managing a multi-node network, including addressing, routing and traffic control.
\end{enumerate}

\subsection{Host layers}

\begin{enumerate}
\item \textbf{Transport}. Reliable transmission of data segments between points on a network, including segmentation, acknowledgement and multiplexing.
\item \textbf{Session}. Managing communication sessions, i.e. continuous exchange of information in the form of multiple back-and-forth transmissions between two nodes.
\item \textbf{Presentation}. Translation of data between a networking service and an application; including character encoding, data compression and encryption/decryption.
\item \textbf{Application}. High-level APIs, including resource sharing, remote file access.
\end{enumerate}

\section{Medium access control}

\subsection{IEEE 802.11}

In the 802.11 LAN, stations use CSMA/CA to mitigate the difficulty to sense colliding transmissions by leaving small gaps between frames. The stations can also use the RTS/CTS protocol to combat hidden terminals that arise because of the fact that the coverage regions of stations may differ  \cite[p.~349]{computer-networks-tanenbaum-2012}.

\subsection{Devices}

In order to be able to better differentiate the following devices it is important to note that they operate in \textbf{different layers}.

\subsubsection{Repeaters and hubs}

\textbf{Repeaters} do not understand frames, packets, or headers.
They just clean up, amplify, and repeat their input as their output.

\textbf{Hubs} just join their input lines electrically.
Therefore, frame collisions can happen through a hub.
All the lines coming into a hub must operate at the same speed.
Hubs, just like repeaters, only care about electric signals.

\subsubsection{Switches}

Switches can be used to join LANs into larger LANs.
They operate in the data link layer, examining the data link layer address to forward frames.
Because they are not supposed to examine the payloads of the frames, they can handle any network layer protocol.
Unlike a hub, \textbf{each port has its own collision domain}.

If the port has a full-duplex point-to-point line, the CSMA/CD algorithm is not needed.
When a frame arrives, the switch extracts the destination address from the frame header and looks it up in a table to see where to send the frame.
For Ethernet, this address is the 48-bit Ethernet destination address.
The bridge only outputs the frame on the port where it is needed and can forward multiple frames to different ports at the same time.

There are two algorithms used to create transparent bridges (that is, bridges which do not require any additional configuration): a \textit{backward learning algorithm} to stop traffic being sent where it is not needed, and a \textit{spanning tree algorithm} to break loops that may be formed by connecting switches without much thought \cite[p.~333]{computer-networks-tanenbaum-2012}.

Switches have much better performance than hubs, and can also allow for the connection lines of different speeds. Internal buffers allow a switch to accept a frame on a port of a given speed and transmit it to another port at a different speed. Buffers are needed even if all the ports have the same speed as the switch may have to temporarily store frames if multiple ports are sending to the same destination port \cite[p.~341]{computer-networks-tanenbaum-2012}.

The term \textbf{bridge} was used to denote switches but is not a popular term anymore. The terms ``bridge'' and ``switch'' can nowadays be used interchangeably \cite[p.~350]{computer-networks-tanenbaum-2012}.

\subsubsection{Routers}

Routers completely discard the data link layer header as they route packets instead of frames and for routing packets the physical source address does not matter.
The routing software only cares about the IPv4 or IPv6 address to make its routing decisions.

\subsection{Virtual LANs}

It is a good practice to group users on LANs to reflect the organizational structure rather than the physical layout of the buildings. Three major reasons for the proper grouping of LANs are \textbf{security}, \textbf{load balance} and \textbf{broadcast traffic}.

Security, for instance, might be related to the fact that one LAN might host computers which are publicly exposed for external use, while another LAN might contain confidential information which should never be publicly exposed  \cite[p.~343]{computer-networks-tanenbaum-2012}.

Load might be an issue if a given department is using all their network bandwidth. This congestion should ideally be isolated from all other departments \cite[p.~344]{computer-networks-tanenbaum-2012}.

Broadcast messages consume substantial LAN capacity on large LANs, so keeping the number of devices in a LAN low is a good idea to reduce the impact of broadcast traffic \cite[p.~344]{computer-networks-tanenbaum-2012}.

Given these reasons, it is important to be able to separate the logical topology from the physical topology.
Another reason for this decoupling is that the number of ports in a switch might be too low or too high for the number of users in a single LAN.

This gave rise to standards for virtual LANs (VLANs). They are based on VLAN-aware switches, because for VLANs to work correctly it is important that the switches know which VLANs are accessible through which ports.

VLANs have been implemented according to the 802.1Q standard, issued in 1998. They caused a change in the Ethernet header, which could be gradually adopted because these new headers were only needed on the switches. 802.1Q raised the maximum frame size from 1518 bytes to 1522 bytes. VLAN-aware switches can configure themselves based on traffic observations \cite[p.~348]{computer-networks-tanenbaum-2012}.

\section{The network layer in the Internet}

In the network layer, the Internet can be viewed as a collection of networks or \textbf{autonomous systems} that are interconnected. Despite there not being any real structure, several major backbones exist. These are constructed from high-bandwidth lines and fast routers.

In the internet, there are \textbf{Interior Gateway Protocols (IGPs)}, which include protocols like RIP, OSPF, IS-IS, and E-IGRP.
In contrast, \textbf{Border Gateway Protocol (BGP)} is an interdomain routing protocol.
Operationally, a key difference between BGP and IGPs is that BGP is concerned with exchanging reachability information between ASes in a scalable manner while allowing each AS to implement autonomous routing policies, whereas the latter are typically concerned with optimizing a path metric.
In general, IGPs do not scale as well as BGP does with respect to the number of participants involved.

A good way to think of the network layer is this: its job is to provide a way to transport packets from source to destination, with no regard to whether these machines are on the same network or whether there are other networks in between them and without delivery guarantees \cite{computer-networks-tanenbaum-2012}.

Communication in the Internet happens through the transport layer, which takes data streams and breaks them up so that they are viable IP packets. Even though IP packets can be up to 64 KiB, in practice they are not more than 1500 bytes (to make sure they fit in a single Ethernet frame) according to \cite{computer-networks-tanenbaum-2012}.
IP routers forward packets until the destination is reached. At the destination, the network layer reassembles the packets into the original datagram, which is then handled to the transport layer.
It is the job of the \textbf{IP routing protocols} to decide which of the usually many possible paths to the destination to take.

\subsection{Virtual circuit and datagram networks}

While the transport layer connections are \textbf{process-to-process}, the network layer connections are \textbf{host-to-host} \cite[p.~313]{computer-networking-kurose-2012}.
In all major computer network architectures to date the network layers provide either a host-to-host connectionless service or a host-to-host connection-oriented service, but never both. Connection-oriented services are called \textbf{virtual circuit networks} at the network layer, while computer networks that only provide a connectionless service at the network layer are called \textbf{datagram networks} \cite[p.~313]{computer-networking-kurose-2012}.

Connection-oriented services in the transport layer are implemented at the edge of the network in the end systems, however, in the network layer connection services are implemented in the routers as well as in the end systems.

\subsubsection{Virtual circuit networks}

A virtual circuit (VC) consists of a path (a series of links and routers), VC numbers (one for each link along the path), and entries in the forwarding table of each router along the path.

A packet of a VC will carry a VC number in its header. However, because a virtual circuit may have a different VC number on each link, each intervening router must replace the VC number of each packet with a new VC number, obtained from the forwarding table \cite[p.~314]{computer-networking-kurose-2012}.

There are two main reasons for each link using its own VC number. First, using a by-link VC number reduces the required size of the field. If all the network used the same value, the field could need many more bits than it does if it is assigned on a by-link basis. Second, and more importantly, the VC setup is simplified by permitting a different VC number at each link along the path of the VC. Specifically, with multiple VC numbers, each router can choose a VC without caring about the VC numbers the other routers are using. If it were required for all routers to use a common VC for the same connection there would be many message exchanges to reach consensus about which number to use \cite[p.~315]{computer-networking-kurose-2012}.

In a VC network, routers must maintain \textbf{connection state information}.

The three common phases in a virtual circuit are:
\begin{enumerate}
    \item \textbf{VC setup}. During the setup phase, the transport layer contacts the network and waits for the network to setup the VC. This involves adding an entry in the routing table of each router along the path.
    \item \textbf{Data transfer}. As expected, after the virtual circuit is established, packets can begin to flow through the VC.
    \item \textbf{VC teardown}. This is initiated by the sender, which must inform the network of its desire to terminate the VC. The network layer then typically informs the other end system about the termination and updates the forwarding tables in all intermediary routers.
\end{enumerate}

A major difference between VC setup at the network layer and connection setup at the transport layer (as the TCP handshake) is that the \textbf{connection setup at the transport layer involves only the two end systems}. However, in VC network, \textbf{routers along the path between the two end systems are involved in VC setup, and each router must be aware of all VCs passing through it} \cite[p.~316]{computer-networking-kurose-2012}.

The messages sent to initiate and terminate a VC are called \textbf{signaling messages}, and their protocols are called \textbf{signaling protocols}.

\subsubsection{Datagram networks}

In a datagram network, such as the Internet, each time an end system needs to send a packet, it just has to fill in the destination address and put the packet on the network.
Each router along the path just looks at the packet destination address to decide how it will forward the packet.
The router forwarding table uses the \textbf{longest matching prefix} to determine which interface to use \cite[p.~318]{computer-networking-kurose-2012}.

Because forwarding tables in datagram networks can be modified at any time, a series of packets sent from one end system to another may follow very different paths and, as a consequence, arrive out of order \cite[p.~319]{computer-networking-kurose-2012}.

\subsection{Routing algorithms}

The main function of the network layer is routing packets.
The routing algorithm is the part of the network layer software responsible for deicing which output an incoming packet should take when leaving the router.
In a datagram network, routing decisions must be made for every data packet since the best route may have changed.
However, if the network uses virtual circuits, routing decisions are made only when a new virtual circuit is set up and packets will only follow the established route \cite[p.~362]{computer-networks-tanenbaum-2012}.

One can think that a router has two processes inside it.

\begin{enumerate}
    \item \textbf{Forwarding}.
    It handles each packet as it arrives, looking up the outgoing line to use for it in the routing tables.
    \item \textbf{Routing}.
    It is responsible for filling in and updating the routing tables.
\end{enumerate}

The desired properties of a routing algorithm are: correctness, simplicity, robustness, stability, fairness, and efficiency.
Correctness and simplicity are self-explanatory, but the need for robustness may be less obvious.
The routing algorithm should be able to cope with changes in the topology and traffic without requiring all jobs in all hosts to be aborted \cite[p.~363]{computer-networks-tanenbaum-2012}.

Stability is also important. There exist routing algorithms that \textit{never} converge to a fixed set of paths.
A stable algorithm reaches equilibrium and stays in equilibrium.
The convergence should be quick, since communication may be disrupted while the algorithm is reaching equilibrium \cite[p.~363]{computer-networks-tanenbaum-2012}.

\textbf{Fairness and efficiency are often contradictory goals}.
Minimizing the mean packet delay and maximizing total network throughput are both valid options.
These two goals are also in conflict, since operating queuing systems near capacity implies a long queuing delay.
Many networks try to minimize the distance a packet must travel, or reduce the number of hops a packet must make.
Either choice tends to improve the delay and also reduce the amount of bandwidth consumed per packet, which tends to improve the overall network throughput \cite[p.~363]{computer-networks-tanenbaum-2012}.

\textbf{Nonadaptive routing algorithms} do not use measurements or estimates to make decisions of the current topology and traffic.
Instead, the choice of the route to use to get from point A to point B is computed in advance and downloaded to the routers when the network is booted.
This procedure is sometimes called \textbf{static routing}.
Because it does not respond to failures, static routing is mostly useful for situations in which the routing choice is clear.

\textbf{Adaptive routing algorithms} change their routing decisions to reflect changes in the topology.
Sometimes, changes in traffic are also taken into account.
These dynamic routing algorithms differ in where they get their information, when they change the routes, and what metrics they use for optimization \cite[p.~364]{computer-networks-tanenbaum-2012}.

\textbf{The optimality principle} states that if a router J is on the optimal path between I and K, then the optimal path from J to K also falls along the same route. As a consequence of this, the optimal routes from all sources to a given destination form a \textbf{sink tree} \cite{dynamic-programming-bellman-2003}. Note that multiple sink trees may exist. Routing algorithms have to discover and use the sink trees for all routers.

\subsubsection{Shortest path algorithm}\label{Shortest path algorithm}

The routing algorithm may be a shortest path algorithm, which tries to find shortest paths in a weighted graph on which the edge weights are functions which evaluate how expensive it is to take a given route.
This might be done with Dijkstra's algorithm and is a static routing algorithm.

\subsubsection{Flooding}

Another possibility is called flooding, in which every incoming packet is sent out on every outgoing line except the one it arrived on \cite[p.~368]{computer-networks-tanenbaum-2012}.

Flooding, as one might expect, generates a huge (possibly infinite) number of duplicates. In order to counter this issue, a hop counter is required. The initial value of this counter might be the diameter of the network. A better technique for damming the flood is to keep track of which packets have been flooded in each router, to avoid sending them out a second time \cite[p.~368]{computer-networks-tanenbaum-2012}.

This algorithm ensures that a packet is delivered to every node in the network, which is wasteful if there is a single destination that needs the packet, but effective for broadcasting information. Flooding is tremendously robust, because even if a large number of routers are destroyed, flooding will find a path (if one still exists) to get a packet to its destination. It also requires very little setup \cite[p.~370]{computer-networks-tanenbaum-2012}.

\subsubsection{Distance vector routing}\label{Distance vector routing}

A distance vector routing algorithm operates by having a table in each router giving the best known distance to each destination and which link to use to get there.
These tables are updated by communicating with neighbor routers.
Eventually, every router should know the best link to reach each destination.
It is sometimes called the \textbf{distributed Bellman-Ford algorithm}.

Distance vector routing is useful as a simple technique by which routers can collectively compute shortest paths, but its convergence (the settling of routes to best paths across the network) may be too slow \cite[p.~372]{computer-networks-tanenbaum-2012}.

Assuming synchronized routing table exchanges, if a network's longest path has N hops, within N exchanges all routers will know about an improvement \cite[p.~372]{computer-networks-tanenbaum-2012}. However, propagating to the network that a route is now slower is much less efficient. Due to a problem known as the \textbf{count-to-infinity problem} \cite[p.~373]{computer-networks-tanenbaum-2012}, if there are no more routes to a given router, the distance to it in the routing tables will approach the value defined to represent infinite distance linearly, which may take a very long time. Therefore, one could say that \textit{this algorithm reacts rapidly to good news, but slowly to bad news}.

\subsubsection{Link state routing}\label{Link state routing}

Link state routing is the historical successor of distance vector routing algorithm and it does not have the count-to-infinity problem \cite[p.~373]{computer-networks-tanenbaum-2012}.

The algorithm can be described in the five following parts.

\begin{enumerate}
    \item Discover the neighbors and learn their addresses.
    \item Set the distance to each neighbor.
    \item Construct a packet with all this information.
    \item Send this packet to and receive similar packets from all other routers.
    \item Compute the shortest path to every other router.
\end{enumerate}

This process distributes the complete topology to every router, thus allowing Dijkstra's algorithm to be used at each router to find the shortest path to every other router \cite[p.~374]{computer-networks-tanenbaum-2012}.

Link state routing requires more memory and computation than distance vector.
For a network with \(n\) routers, each with up to \(k\) neighbors, the memory required to store the input data is proportional to \(kn\). Also, the computation time grows faster than \(kn\), an issue in large networks.
However, link state routing works well because it doesn't have slow convergence problems.
Many ISPs use the \textbf{IS-IS} (Intermediate System-Intermediate System) link state protocol.
\textbf{OSPF} (Open Shortest Path First) is the other main link state protocol \cite[p.~378]{computer-networks-tanenbaum-2012}.

It is important to understand that link state routing, distance vector routing, and some other algorithms rely on processing at all the routers to compute routes. Problems at even a small number of routers can disrupt the whole network. As the network grows, the probability of at least one router failing gets bigger, so it is important to think about this when designing large networks \cite[p.~378]{computer-networks-tanenbaum-2012}.

\subsubsection{Hierarchical routing}\label{Hierarchical routing}

With network growth comes routing table growth.
Bigger routing tables require more memory to store them, more CPU time to scan them, and more bandwidth to send them around \cite[p.~378]{computer-networks-tanenbaum-2012}.
There is a point at which the tables are so big that it is no longer feasible to have each router know about every other router, so the routing has to be done hierarchically, very much like in telephone networks \cite[p.~379]{computer-networks-tanenbaum-2012}.

In hierarchical routing, the routers are divided into \textbf{regions}.
Each router knows all the details about how to route packets to destinations within its own region, but does not know about the structure of other regions \cite[p.~379]{computer-networks-tanenbaum-2012}.

For very large networks, regions may not be enough, then more levels of aggregation are required.
These gains are not free, because in many cases the path grows as we need to reach upper aggregation levels instead of sending directly to another router \cite[p.~379]{computer-networks-tanenbaum-2012}.

It 1979, it was shown that the optimal number of levels for a network with \(N\) routers is \(\ln n\), which requires a total of \(e \ln N\) entries per routing table. It was also shown that the increase in effective mean path length caused by hierarchical routing is sufficiently small that it is usually acceptable \cite{kamoun-kleinrock-1976}.

\subsubsection{Broadcast routing}

Sending a packet to all destinations is called \textbf{broadcasting}.
The trivial solution of sending multiple packets, one for each destination, is called \textbf{separately addressed packets}.
An improvement to the trivial solution is to use \textbf{multidestination routing}.
In this case each packet contains either a list of destinations or a bitmap which indicates to which devices the packet has to be delivered. Both solutions require the source to know all the destinations.

A better broadcasting technique is \textbf{flooding}, which is not a very good solution for point-to-point communication. However, if properly implemented using a sequence numbers per source, it is a very efficient broadcasting algorithm \cite[p.~381]{computer-networks-tanenbaum-2012}.

However, one can do better than flooding by using \textbf{reverse path forwarding}, which requires all the shortest path routes for regular packets to have been computed. This algorithm analyzes the link through which the packet arrived at the router. If it came from the the link that is normally used for sending packets toward the source of the broadcast, there is an excellent chance that the broadcast packet itself followed the best route to the router and is the first copy to arrive. Then the router forwards copies of it onto all links except the one it arrived one. If, however, the broadcast packet arrived on a link other than the best one, the packet is discarded as it is likely a duplicate. This algorithm does not need to know in anticipation all the destinations and it does not require any methods for flood control \cite[p.~381]{computer-networks-tanenbaum-2012}.

A last alternative, which is optimal, is to use a \textbf{spanning tree} of the network. If each router knows the sink tree of the network, then it is possible to do broadcasting with forwarding perfection. However, this requires each router to be able to compute the sink tree, which is possible when using some routing algorithms, such as link state routing, but impossible under other algorithms, such as distance vector routing \cite[p.~382]{computer-networks-tanenbaum-2012}.

\subsection{Packet fragmentation}\label{Packet fragmentation}

There are two approaches for packet fragmentation in networks, \textbf{transparent fragmentation}, which performs reassembly if the router knows it is sending to a ``larger-packet'' network, and \textbf{nontransparent fragmentation}, which performs no packet reassembly in intermediary nodes.
Transparent fragmentation might be quite wasteful if the packets are being constantly disassembled and reassembled in intermediary nodes.
Nontransparent fragmentation requires less work from the routers.
IP works by using nontransparent fragmentation.
It gives every fragment a packet number, an absolute byte offset within the packet, and a flag indicating whether it is the end of the packet \cite[p.~434]{computer-networks-tanenbaum-2012}. This allows for fragments as small as a single byte plus the header size.

Because of the inefficiency introduced by packet fragmentation, the modern Internet uses path MTU discovery, so that the fragmentation is done in the sending host \cite[p.~435]{computer-networks-tanenbaum-2012}.

\subsection{IP addresses}

IP addresses are hierarchical, unlike Ethernet addresses. Each 32-bit address is comprised of a variable-length network portion in the top bits and a host portion in the bottom bits.
The network portion is \emph{common across shared by all the same value for all hosts on a single network}.
This means that a network corresponds to a contiguous block of IP address space with a common prefix \cite{computer-networks-tanenbaum-2012}.

IP addresses are assigned to interfaces and not to computers.
Therefore, one computer can have more than one IP address.

\subsection{ARP}

ARP (Address Resolution Protocol) is a protocol run by almost every machine on the Internet. It is defined in RFC
826. It allows for configuration-less MAC resolution from IPv4 addresses. Essentially, a computer will broadcast a request for the MAC of whoever has a given IPv4 address. The device with this IPv4 address then will reply with its own MAC, thus resolving the question \cite{computer-networks-tanenbaum-2012}.

\subsection{IPv4}

The IPv4 header uses \textbf{big-endian integers}. Little endian would have been a better choice, but at the time IP was designed, no one knew it would dominate computing \cite{computer-networks-tanenbaum-2012}.

The \textbf{version} field keeps track of which version of the protocol the datagram belongs to. By including the version on datagram, it becomes possible to have a slow transition between versions over a period of time.

The header length is not constant. There's a field in the header, IHL, to tell how long the header is, in 32-bit words. The minimum value of this field is 5, which applies when no options are present.
The maximum value of this 4-bit field is 15, which limits the header to 60 bytes, and the options field to 40 bytes. For some options, such as one that records the route a packet has taken, 40 bytes is far too small.
This makes those options effectively useless \cite{computer-networks-tanenbaum-2012}.

The \textbf{differentiated services} field is one of the few fields that has changed its meaning (slightly) over the years \cite{computer-networks-tanenbaum-2012}.
It was and still is used to distinguish between different classes of service, making various combinations of reliability and speed possible.
For digitized voice, fast delivery beats accurate delivery.
For file transfer, error-free transmission is more important than fast transmission \cite{computer-networks-tanenbaum-2012}.
This field provided 3 bits to signal priority and 3 bits to signal whether a host cared more about delay, throughput, or reliability.
However, no one really knew what to do with these bits at routers, so they were left unused for many years.
When differentiated services were designed, \href{https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force}{IETF} threw in the towel and reused this field.
Now, the top 6 bits are used to mark the packet with its service class.
The bottom 2 bits are used to carry explicit congestion notification information, such as whether the packet has experienced congestion \cite{computer-networks-tanenbaum-2012}.

The \textbf{total length} field in the IPv4 includes everything in the datagram: both header and data.
The maximum length is 65,535 bytes. At present, this upper limit is tolerable, but with future networks, larger datagrams may be needed according to \cite{computer-networks-tanenbaum-2012}.
\textbf{I have no idea as to why the datagram limit is an issue}.
See my \href{https://networkengineering.stackexchange.com/questions/54480/why-is-the-ip-datagram-total-length-an-issue}{Network Engineering Stack Exchange question}.

Next comes an unused bit, which is surprising, as available real estate in the IP header is extremely scarce.
As an April Fool's joke, Bellovin proposed using this bit to detect malicious traffic.
This would greatly simplify security, as packets with the ``evil'' bit set would be known to have been sent by attackers and could just be discarded.
This bit, as one might expect, serves no purpose \cite{computer-networks-tanenbaum-2012}.

The 8-bit \textbf{time to live} field is a counter used to limit packet lifetimes.
\textit{In practice, it just counts hops}.
When it hits zero, the packet is discarded and a warning packet is sent back to the source host.
\textbf{This feature prevents packets from wandering around forever, something that otherwise might happen if the routing tables ever become corrupted} \cite{computer-networks-tanenbaum-2012}.

The \textbf{protocol} field tells it which transport process to give the packet to.
Protocols and other assigned numbers are contained in an online database located at \href{https://www.iana.org}{the Internet Assigned Numbers Authority}.

As the header carries vital information, it has its own checksum for protection. However, there is a lot of redundancy as Ethernet, TCP and UDP all have checksums too.

\subsection{IPv5}

IPv5 was an experimental real-time stream protocol that was never widely used \cite{communication-networks-leon-garcia-2000}.
It was initially envisioned that the ST-2 protocol would become IPv5, but ST-2 was later dropped \cite{computer-networking-kurose-2012}.

\subsection{IPv6}
In the early 1990s, as the IPv4 address space was being used up, a new IP protocol was developed.
It's design took into consideration operational experience with the IPv4.

\subsubsection{IPv6 datagram format}

The address changed from 32 to 128 bits.
This makes it so that \textit{every grain of sand on the plant can be IP-addressable}\footnote{Earth has roughly \(7.5 \times 10^{18}\) grains of sand, a bit less than \(2^{63}\).} according to \cite{computer-networking-kurose-2012}.
In addition to the unicast and multicast addresses, IPv6 has a new type of address called the \textbf{anycast address}, which allows a datagram to be delivered to any \textbf{one} of a group of hosts.

The header now has a fixed 40-byte size.
The IPv6 datagram is also limited to 65,535 bytes, but the new payload length field does not take the fixed-length 40-byte header into account.
The \href{https://tools.ietf.org/html/rfc2675}{RFC 2675} allows for much larger payloads by using a 32-bit length field.

IPv6 also has a definition of \textbf{flow}. This allows packets to be labelled for special handling if they belong to certain flows, such as the packets of real-time video transmissions.
The designers of IPv6 foresee the eventual need to be able to differentiate among the data flows \cite{computer-networking-kurose-2012}.

IPv6 does not allow for fragmentation at intermediary routers.
If an IPv6 datagram received by a router is too large to be forwarded, the router drops the datagram and sends a ``Packet Too Big'' ICMP error message to the sender.
The sender can then resend the data, using a smaller IP datagram size.
Fragmentation and reassembly is a time-consuming operation and removing this functionality from the routers and placing it in the end systems considerably speeds up IP forwarding within the network \cite[p.~358]{computer-networking-kurose-2012}.

The checksum was removed, as it is already performed by Ethernet at the data link layer and by TCP and UDP at the transport layer.
Because the TTL field of the IPv4 header changes at every hop, this checksum has to be recomputed at every hop.

Even though the options field is no longer a part of the standard IP header, it has not gone away.
The options field is one of the possible next headers pointed from within the IPv6 header, just as TCP or UDP headers might be the next header in an IP packet \cite[p.~359]{computer-networking-kurose-2012}.
There is also a new version of the ICMP protocol, named ICMPv6 for the new IPv6 features.

\subsubsection{IPv4 to IPv6 transition}

The transition from IPv4 to IPv6 is difficult. Even though newer systems can support IPv4, legacy systems may not support IPv6. The idea of a single world-wide reboot to IPv6 isn't practical. The most straightforward way to introduce IPv6 nodes is the \textbf{dual-stack} approach. In this approach IPv6 nodes have a complete IPv4 implementation.

For this to work a node has to have a way to figure out whether or not another node is IPv6-capable. This is done through DNS. The DNS resolution returns either an IPv4 or an IPv6 address to indicate that the node is IPv6-capable or not \cite[p.~360]{computer-networking-kurose-2012}.

An alternative is \textbf{tunneling}. It solves the problem by allowing IPv6-capable nodes to interoperate even if they are connected to each other by intervening IPv4 routers. This is done by putting the entire IPv6 datagram in the payload of the IPv4 datagram. The intervening IPv4 routers in the tunnel route this IPv4 datagram among themselves, just as they would any other datagram, blissfully unaware that the IPv4 datagram itself contains a IPv6 datagram \cite[p.~360]{computer-networking-kurose-2012}.

Europe's Third Generation Partnership Program specified IPv6 as the standard addressing scheme for mobile multimedia \cite[p.~362]{computer-networking-kurose-2012}.

IPv6 has taught us that it is enormously difficult to change network-layer protocols. Since the early 1990s, numerous new network-layer protocols have been trumpeted as the next major revolution for the
Internet, but most of these protocols have had limited penetration to date.
These protocols include IPv6, multicast protocols, and resource reservation protocols.
On the other hand, at the application layer the Internet has witnessed rapid deployment of new protocols: the Web, instant messaging, P2P file sharing, multimedia streaming, and distributed games \cite[p.~362]{computer-networking-kurose-2012}.

\section{Transport layer}

\subsection{TCP}

Transmission control protocol (TCP) was specifically designed to provide a reliable end-to-end byte stream over an unreliable network.
TCP was created to dynamically adapt to properties of the network and to be robust in the face of many kinds of failures.

When talking about TCP/IP, it is common to group OSI layers 1 and 2 under Network Interface and 5, 6, and 7 under Application.

\section{Application layer}

\subsection{HTTP}

\subsubsection{Non-persistent and persistent connections}

In many applications, multiple HTTP requests are done in a short period of time.
Therefore, the developer has to make a decision between sending these requests over separate TCP connections (using \textbf{non-persistent connections}) or over the same TCP connection (using \textbf{persistent connections}) \cite[p.~100]{computer-networking-kurose-2012}. By default, HTTP uses persistent connections.
HTTP (which is defined in \href{https://tools.ietf.org/html/rfc1945}{RFC 1945} and \href{https://tools.ietf.org/html/rfc2616}{RFC 2616}) does not define anything regarding HTML.

The following enumeration is an explanation of a request to a server to obtain an HTML page with one JavaScript file referenced using non-persistent connections.

\begin{enumerate}
\item The HTTP client opens a TCP connection to the server.
This requires a socket in the client and a socket in the server.
\item The HTTP client sends an HTTP request message to the server through this socket.
\item The server reads the HTTP message and answers it by sending back an HTTP response.
\item The HTTP server tells TCP stack to close the connection.
The connection will be closed when TCP knows the client has received the whole message.
\item The client application now extracts the payload of the message and finds a HTML file which references another file.
\end{enumerate}

After the last step, the client application will need to open another TCP connection to request the file mentioned in the HTML document.

When using HTTP with non-persistent connections, each connection transports exactly one request and one response \cite[p.~101]{computer-networking-kurose-2012}.
Browsers using non-persistent connections can use parallel connections to speed up the process of loading an entire page.

Roughly, the time taken to obtain a response using non-persistent connections is two RTTs plus the time it takes for the client to send the request and the time it takes for the server to send the response.
This is because the third part of the TCP handshake can already include the request in it \cite[p.~102]{computer-networking-kurose-2012}.

With persistent connections, the client can reuse a connection to send multiple requests. These requests can be made back-to-back, without waiting for replies.
This is called \textbf{pipelining}.

Typically, the HTTP server will close a connection which has not been used for a certain time \cite[p.~103]{computer-networking-kurose-2012}.

\subsubsection{HTTP status codes}

HTTP status codes convey the result of the attempts of the server to satisfy the request.

\begin{itemize}
 \item 1xx : informational
 \item 2xx : success
 \item 3xx : redirection
 \item 4xx : client error
 \item 5xx : server error
\end{itemize}

\subsection{File transfer protocol (FTP)}

FTP is used to allow a local host to transfer files to or from a remote host. The protocol uses password authentication but uses no encryption whatsoever \cite[p.~116]{computer-networking-kurose-2012}.

FTP uses TCP on the ports 20 and 21 for data and control, respectively \cite[p.~117]{computer-networking-kurose-2012}. Because of this separation, one can say that FTP sends its control information \textbf{out-of-band}. HTTP, however, sends its control information \textbf{in-band}.

In FTP, a single control connection is used throughout the user session. However, a new data connection is created for each file transferred. The server also has to keep \textbf{state} for each open session.

\section{Network security}

In the first decades of computer networks, they were used for university researches sharing emails and corporate employees sharing printers. Because of this, security was not a core concern. However, people started using it for all sorts of financial transactions and private information, which made security a main concern.

Security can be divided roughly into security, authentication, nonrepudiation, and integrity control. \textbf{Secrecy} deals with keeping information out of the hands of unauthorized users. \textbf{Authentication} deals with determining who you are talking with before revealing sensitive information. \textbf{Nonrepudiation} deals with signatures and proving that someone did something. \textbf{Integrity control} has to do with ensuring that the received message is really the one sent and not something that a malicious adversary modified in transit \cite[p.~764]{computer-networks-tanenbaum-2012}.

All of the protocol stack layers can contribute to security. One might use sealed tubes with an inert gas to protect cables and monitor for pressure variations in order to detect tampering \cite[p.~765]{computer-networks-tanenbaum-2012}. In the data link layer, \textbf{link encryption} can be used. It involves encrypted packets ad they leave one link and decrypting them when they reach another \cite[p.~765]{computer-networks-tanenbaum-2012}.
In the network layer, \textbf{firewalls} can be installed to keep some packets out. IP security also works on the network layer \cite[p.~765]{computer-networks-tanenbaum-2012}.
In the transport layer, connections can be encrypted end-to-end, that is, process-to-process \cite[p.~765]{computer-networks-tanenbaum-2012}.
User authentication and nonrepudiation can only be properly handled in the application layer \cite[p.~765]{computer-networks-tanenbaum-2012}.

It is well-documented that most security failures at banks, for example, are due to engineering incompetence and lax security procedures in the name of good customer relations \cite[p.~765]{computer-networks-tanenbaum-2012}.

\subsection{Cryptography}

\textbf{Cryptography} is the foundation of most of network security.
A \textbf{cipher} is a character-for-character transformation, with no regard to the linguistic structure of the message \cite[p.~766]{computer-networks-tanenbaum-2012}.

A \textbf{passive intruder} just listen to the messages being transmitted, while an \textbf{active intruder} can manipulate messages \cite[p.~767]{computer-networks-tanenbaum-2012}.

The messages to be encrypted are known as the \textbf{plaintext}. They are transformed by a function parameterized by a \textbf{key}.
The output of this function is the \textbf{ciphertext}, which might be intercepted by an \textbf{intruder}, which we should assume can copy the complete ciphertext.
However, only the intended recipients have the \textbf{decryption key}, and therefore only they can decode the ciphertext.
\textbf{Cryptanalysis} is the art of breaking ciphers.

The effort of invent, test, and install a new cryptographic algorithm has always made it impractical to keep the encryption algorithm secret.
Thinking it is secret when it isn't does more harm than good \cite[p.~768]{computer-networks-tanenbaum-2012}.

\textbf{Kerckhoff's principle} states that the algorithms should be public, and only the keys secret \cite[p.~768]{computer-networks-tanenbaum-2012}.

\textbf{Security by obscurity} is the name given to the practice of trying to keep the algorithm itself secret.
This is generally regarded as a bad idea. The longer the key used, the higher the \textbf{work factor} for the cryptanalyst.
From the cryptanalyst point of view, there are three principal variations of the cryptanalysis problem.

\begin{enumerate}
    \item \textbf{Ciphertext-only}. The cryptanalyst only has ciphertext.
    \item \textbf{Known plaintext}. The cryptanalyst has some ciphertext and matching plaintext.
    \item \textbf{Chosen plaintext}. The cryptanalyst has the ability to encrypt pieces of plaintext.
\end{enumerate}

\subsubsection{Substitution ciphers}

Substitution ciphers work by mapping each character into another character.
Even though ciphers are statistically secure, they may easily be broken if the frequency distribution of the values of the original message is known.

\subsubsection{Transposition ciphers}

While substitution ciphers preserve the plaintext order but disguise the symbols, transposition ciphers reorder the symbols without disguising them \cite[p.~771]{computer-networks-tanenbaum-2012}.

\subsubsection{One-time pads}

One-time pads are a way to construct an unbreakable cipher.
It uses a random bit string of the same length as the plaintext as the key and calculates the exclusive or between the key and the original message.
There is simply no information in the message because all possible plaintexts of the given length are equally likely.
It is important to point out that for any plaintext, there will be a key which converts any ciphertext of same length into this plaintext \cite[p.~772]{computer-networks-tanenbaum-2012}.

\subsubsection{Fundamental cryptographic principles}

\textbf{All encrypted messages must contain some redundancy}.
One can state this redundancy as the property that the recipient must be able to tell whether a decrypted message is valid by a simple examination of the message.
If the messages have no redundancy, almost any message will be a valid message, which is not a good thing as attackers may easily create fake messages.
Therefore, redundancy is needed to prevent active intruders from sending garbage and tricking the receiver into acting over the decrypted garbage.
However, this same redundancy makes it much easier for passive intruders to break the system \cite[p.~778]{computer-networks-tanenbaum-2012}.

\textbf{Each encrypted messages can be verified as being fresh}. This is needed to help prevent active intruders from just resending old messages.

\subsection{Symmetric-key algorithms}

Nowadays, due to the advent of computers, cryptographic algorithms have to be so complex so that even if the cryptanalyst can acquire a vast amount of enciphered text, he will not be able to decrypt it without the key.

Symmetric-key algorithms use the same key for encryption and decryption. Block ciphers transform a block of plaintext into a block of ciphertext \cite[p.~779]{computer-networks-tanenbaum-2012}.

In the literature, an iteration of a cryptographic algorithm over the data is called a \textbf{round} \cite[p.~780]{computer-networks-tanenbaum-2012}.

\subsubsection{DES and AES}

The \textbf{Data Encryption Standard (DES)} algorithm was originally developed by IBM.
Some controversy arose from the fact that the NSA reduced its key size from 128 bits to 56 bits.
People suspected that the key length was reduced to make sure that NSA could just break DES, but not organization with a smaller budget could.
Today, for less than US\$ 10,000 one can buy a machine that breaks DES in under 1 day given plaintext and matching ciphertext \cite[p.~782]{computer-networks-tanenbaum-2012}.

Triple DES was proposed some time after DES. It used two 56-bit keys instead of one and worked by encrypting with \(K_1\), decrypting with \(K_2\), and then encrypting with \(K_1\).
This was done for backwards compatibility.
Because of the way DES was designed, a decryption step should be just as good as an encryption step, but using encrypt-decrypt-encrypt instead of encrypt-encrypt-encrypt allowed for legacy systems to set \(K_1 = K_2\) and be able to communicate with newer systems \cite[p.~783]{computer-networks-tanenbaum-2012}.

In 1997, the NIST sponsored a public contest for a new cryptographic algorithm to determine the algorithm for the \textbf{Advanced Encryption Standard (AES)}.
The contest rules were the following.

\begin{enumerate}
\item The algorithm must be a symmetric block cipher.
\item The full design must be public.
\item Key lengths of 128, 192, and 256 bits must be supported.
\item Both software and hardware implementations must be possible.
\item The algorithm must be public or licensed on nondiscriminatory terms.
\end{enumerate}

In 2000, NIST announced that it had selected Rijndael (pronounced rhine-doll) for AES.
Due to the openness of the competition and the fact that the winning team consisted of two young Belgian cryptographers who were unlikely to have any ties to the NSA, Rijndael has become the world's main cryptographic cipher.
AES encryption and decryption is today part of some instruction sets, such as Intel's \cite[p.~784]{computer-networks-tanenbaum-2012}.

AES has two variants: 128-bit block with 128-bit key and 128-bit block with 256-bit key.

\subsubsection{Cipher modes}

Despite their complexity, AES and all other block ciphers are just a monoalphabetic substitution cipher using big characters (128-bit characters for AES and 64-bit characters for DES) \cite[p.~787]{computer-networks-tanenbaum-2012}.
Therefore, the way one uses the cipher matters greatly.

For instance, the \textbf{electronic code book} mode simply replaces each plaintext block with a ciphertext block.
It is unsafe, as intruders may just swap blocks around and get a valid message as a result.

One alternative possibility is the \textbf{cipher block chaining} mode, in which each plaintext block is XORed with the previous ciphertext block before encryption.
The main reason for using cipher block chaining is that it makes cryptanalysis more difficult because the same plaintext block may result in different ciphertext blocks depending on the message \cite[p.~789]{computer-networks-tanenbaum-2012}.

Other possibilities include the \textbf{cipher feedback} mode, the \textbf{stream cipher} mode, and the \textbf{counter} mode.

\subsubsection{Cryptanalysis}

A relevant development in cryptanalysis is \textbf{differential cryptanalysis}, which can be used to attack any block cipher.
It consists of observing what the algorithm does to very similar plaintext blocks, which can show that some patterns are more common than others, which then lead to probabilistic attacks.

Another notable development is \textbf{linear cryptanalysis}.
It works by XORing certain bits in the plaintext and ciphertext together and examining the result.
When done repeatedly, half the bits should be zeros, and half the bits should be ones.
However, most ciphers introduce a bias in one direction or the other, and this bias, however small, can be exploited to reduce the work factor \cite[p.~793]{computer-networks-tanenbaum-2012}.

Yet another development is the \textbf{power consumption analysis} to find secret keys.
If the CPU is processing the secret key bit by bit, it is possible to monitor its power usage to find out what the secret key is.
Therefore, the power consumption should be made independent of the keys used to prevent these types of attacks \cite[p.~793]{computer-networks-tanenbaum-2012}.

Lastly, it is also worth mentioning \textbf{timing analysis}. The time certain parts of the algorithm take usually depends on the keys used.
Therefore, by monitoring how much time each step of the computation takes, it is sometimes possible to calculate what the secret key was.

Even though power consumption analysis and timing analysis may seem nearly impossible to do right, they are powerful techniques which can break ciphers which were not designed to resist them \cite[p.~793]{computer-networks-tanenbaum-2012}.

\subsection{Public-key algorithms}

Distributing the secret keys was always a challenge in cryptographic systems. It had to be distributed, otherwise cryptography could not be used, but it could only be distributed to some hosts.
In 1976, Diffie and Hellman proposed a new kind of system. In it, there were two keys, one for encryption and one for decryption, which could not easily be derived from one another \cite[p.~794]{computer-networks-tanenbaum-2012}.

This allows for a party interested in a safe communication channel to publish the public key, which will then be used by the senders to encrypt the message, and keep the private key, which will be used by the recipient to decrypt the message.

As a note on terminology, I will try to use \textit{public} and \textit{private} when referring to public-key algorithms and \textit{secret} when writing about symmetric-key cryptography.

\subsubsection{RSA}

One algorithm which implements public-key cryptography is the RSA.
Its security is based on the difficulty of factoring large numbers \cite[p.~795]{computer-networks-tanenbaum-2012}.

It is important to note that RSA is too slow for encrypting large volumes of data, so it is widely used just for key distribution.
After keys have been safely exchanged, a symmetric-key algorithm such as AES is used for data encryption \cite[p.~796]{computer-networks-tanenbaum-2012}.

There are other public-key schemes which are based on \textbf{computing discrete logarithms} and on \textbf{elliptic curves} \cite[p.~797]{computer-networks-tanenbaum-2012}.

\subsection{Digital signatures}

Three conditions are important for digital signatures.

\begin{itemize}
\item The receiver can verify the identity of the sender.
\item The sender cannot later repudiate the contents of the message.
\item The receiver cannot possibly have concocted the message himself.
\end{itemize}

\subsubsection{Symmetric-key signatures}

One approach to digital signatures is having an authority that knows everything and which is trusted by everyone.
This entity then can also know the secret key of each agent, therefore allowing it to confirm that an encrypted message actually belongs to a specific agent \cite[p.~798]{computer-networks-tanenbaum-2012}.

\subsubsection{Public-key signatures}

Public-key cryptography can make an important contribution to digital signatures. A possibility is to have Alice encrypt a message using her private key and then encrypt this message with Bob's public key.
\(E_B(D_A(P))\) can be decrypted by Bob and not anybody else \cite[p.~799]{computer-networks-tanenbaum-2012}.

There are problems related to the environment in which public-key cryptography is used.
For instance, Bob can present \(D_A(P)\) to show that he got a message encrypted with Alice's private key.
However, if Alice discloses her private key, then anybody could have send the message and there is no way for Bob to held Alice accountable \cite[p.~800]{computer-networks-tanenbaum-2012}.

Also, the keys cannot be changed periodically, otherwise it would be impossible to validate old messages.

The industry \textit{de facto} standard for public-key signatures is the RSA algorithm.
However, there is also the DSS algorithm, which was proposed by NIST in 1991.
It was heavily criticized for being developed behind closed doors \cite[p.~800]{computer-networks-tanenbaum-2012}.

\subsubsection{Message digests}

Signature methods often couple integrity and confidentiality. However, confidentiality isn't always required.
In these cases, encrypting only a message digest of the plaintext is enough.

MD5 was a popular message digest. Collisions have been found since 2008 \cite[p.~804]{computer-networks-tanenbaum-2012}.

SHA-1 is a hash function which takes an input and produces a 160-bit output.
In 2017, CWI Amsterdam and Google demonstrated a collision attack against SHA-1, publishing two dissimilar PDF files which produced the same hash.

SHA-2 includes significant changes from its predecessor. The SHA-2 family consists of six similar hash functions: SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256.
SHA-2 is prone to length extension attacks, rendering it insecure for some applications.
It is recommended to switch to SHA-3 for 512-bit hashes.
Using SHA-512/224 and SHA-512/256 instead of SHA-224 and SHA-256 is faster on x86-64 processor architecture, mainly because SHA-512 works on 64-bit instead of 32-bit words.

\subsubsection{The birthday attack}

To subvert a \(m\)-bit message digest, around \(2^{m/2}\) operations are needed \cite[p.~804]{computer-networks-tanenbaum-2012}.

\subsection{Management of public keys}

A problem with the solution of just publishing your public key on your own website is that the DNS resolution might be a vulnerability.

\subsubsection{Certificates}

The solution for this problem is the use of a \textbf{certificate authority (CA)} \cite[p.~807]{computer-networks-tanenbaum-2012}.
CAs issue public certificates that a given public key belongs to principal.
These certificates include an encrypted message digest, which can be validated offline.
Because of this, the CAs do not become a bottleneck for certificate validation.

\subsubsection{X.509}

X.509 is the standard for certificates, which ensures that each CA uses the same format.

\subsubsection{Public key infrastructure}

Public key infrastructure (PKI) is a way for certifying public keys without centralized CAs.
This is important so that if a given CA has its private key compromised, not all certificates in the world are invalidated.

The PKI is a hierarchical authority.
For validating a single certificate it is usually necessary a series of certificates which go back to a root of the PKI tree.
This is called a \textbf{chain of trust} or a \textbf{certification path} \cite[p.~812]{computer-networks-tanenbaum-2012}.

The roots of the PKI are sometimes referred to as \textbf{trust anchors}.
This prevents all issues which would come with having a single worldwide authority.

The issue of certificate revocation complicates matters.
This is implemented through certification revocation lists (CRLs) for certificates which have not yet expired \cite[p.~813]{computer-networks-tanenbaum-2012}.

\subsection{Communication security}

Communication security deals with how to get the bits secretly and without modification from source to destination and how to keep unwanted bits out \cite[p.~813]{computer-networks-tanenbaum-2012}.

\subsubsection{IPsec}

One possibility for secure connections is to handle encryption at the application layer.
However, this would requires changing all existing applications, so an alternative to end-to-end encryption is to perform encryption in a layer below the application layer, such as the transport layer.

After some discussion, the view that the encryption and decryption should happen in the network layer was mostly accepted and it got a standard.
The argument was that having network layer encryption does not prevent security-aware users from doing it right and it also helps security-unaware users \cite[p.~814]{computer-networks-tanenbaum-2012}.

The result of this was IPsec. However, not all users wanted encryption because it was computationally expensive.
Rather than making it optional, a \textbf{null algorithm} was allowed to be used.
Another reason for supporting multiple algorithms in IPsec is that if an algorithm is broken, IPsec does not become entirely useless.

The major services provided by IPsec are \textbf{secrecy}, \textbf{data integrity}, and \textbf{protection from replay attacks}.
All of these IPsec services are based on symmetric-key cryptography because it has better performance than public-key cryptography \cite[p.~814]{computer-networks-tanenbaum-2012}.

IPsec also offers multiple granularities, so it is possible to protect a single TCP connection, all traffic between a pair of hosts, or all traffic between a pair of routers.
Even though IPsec is in the IP layer, it is connection-oriented \cite[p.~814]{computer-networks-tanenbaum-2012}.
This is because in order to have security, a key must be established and used for some period of time.
One IPsec connection is called a \textbf{security association (SA)} \cite[p.~815]{computer-networks-tanenbaum-2012}.

IPsec can be used in either \textbf{transport mode}, in which the IPsec header is inserted after the IP header, and in \textbf{tunnel mode} in which the entire IP packet is encapsulated in the body of a new IP packet.
Tunnel mode can help foil \textbf{traffic analysis} to some extent because it can aggregate a bundle of TCP connections as a single encrypted stream, but it increases packet size more than transport mode does.

\textbf{Hashed message authentication code (HMAC)} is a scheme which computes the hash over the concatenation of the payload and the secret key.
The main advantage of HMAC over public-key cryptography is its performance. As one might expect, this provides integrity but no confidentiality.

IPsec can use \textbf{authentication header (AH)} and \textbf{encapsulated security payload (ESP)} as headers.
ESP is generally better because it also provides encryption, even though it does not check part of the IP header like AH does \cite[p.~818]{computer-networks-tanenbaum-2012}.

\subsubsection{Firewalls}

Even though being able to communicate with any computer in the Internet is useful, it might be unnecessary exposure from a corporate point-of-view.
There is both the risk of information leaking out and the risk of information leaking in \cite[p.~818]{computer-networks-tanenbaum-2012}.
Firewalls are a way to filter incoming and outgoing traffic. In many companies, they are the only gateway to get to the Internet, so all traffic might be inspected.

The firewall acts as a \textbf{packet filter}. It can either forward or drop packets, depending on its configuration.
Because many processes use a specific set of ports, many unused ports can be blocked as they are only potential attack vectors.
For instance, port 80 could be blocked so that no HTTP traffic was allowed, while 443 could remain open so that HTTPS traffic was allowed.

Firewalls have become much more sophisticated over time. This is because it proved difficult to write useful rules which could be applied to every single packet.
\textbf{Stateful firewalls} map packets to connections and thus allow for more complex settings, such as allowing an external server to send packets to an internal host only if the internal host first establishes a connection with the external server.

Lastly, firewalls can also implement \textbf{application-level} gateways
This process involves the firewall inspecting the packet contents to understand what the application is doing.
This allows the firewall to distinguish between HTTP traffic used for browsing Wikipedia and HTTP traffic used for peer-to-peer file sharing.
It is important to note that outgoing traffic can also be inspected, so that raw sensitive data never leaves the company office \cite[p.~819]{computer-networks-tanenbaum-2012}.
However, cryptography can be used to mask the outgoing traffic.

Firewalls are network layer devices which peek at the transport and application layers to work, this violates the standard layering of protocols \cite[p.~820]{computer-networks-tanenbaum-2012}.
This is a reason for why some network purists consider firewalls a blemish on the architecture of the Internet.

In order to prevent a firewall breach from allowing complete access to the internal network, multiple firewall layers might be used.
Firewalls offer no protection against \textbf{DoS} and \textbf{DDoS} attacks \cite[p.~820]{computer-networks-tanenbaum-2012}.

\subsubsection{Virtual private network (VPN)}

Some large companies used to have physical network lines between its multiple facilities.
These lines defined a \textbf{private network}.
However, leasing private lines is very expensive, so many companies have financial interest in migrating their networks to the public network, but without giving up the security and privacy of a private network \cite[p.~821]{computer-networks-tanenbaum-2012}.
This led to the invention of VPNs, which are overlay networks on top of public networks with most of the properties of private networks.
They are called virtual because very much like virtual circuits are not real circuits and virtual memory is not real memory virtual networks are not real networks \cite[p.~821]{computer-networks-tanenbaum-2012}.

One popular approach is to build VPNs over the Internet using firewalls. An interesting advantage is that tunnels can be set up on demand to include, for example, the computer of an employee at his home or while he is traveling as long as he has an Internet connection.

When the system is brought up, each pair of firewalls has to negotiate the parameters of its security association, including the services, modes, algorithms, and keys. If IPsec is used for tunneling, it is possible to aggregate all traffic between any pair of offices into a single authenticated, encrypted SA. This can provide integrity control, secrecy, and even some immunity to traffic analysis.

Many firewalls have built-in VPN capabilities.
Some routers can also do this. Therefore, firewalls, VPNs, and IPsec with ESP in tunnel-mode are a natural combination.
For a router in the Internet, a packet traveling along a VPN tunnel is just another IP packet.
The only difference being the presence of the IPsec header after the IP header, which does not matter for the forwarding process \cite[p.~822]{computer-networks-tanenbaum-2012}.

Another possibility is to have the ISP set up the VPN. Using \href{https://en.wikipedia.org/wiki/Multiprotocol_Label_Switching}{multiprotocol label switching}, paths for the VPN traffic can be set up across the ISP network between the company offices. These paths keep the VPN traffic separate from public traffic and can be guaranteed better quality of service.

Except for the configuration steps, VPNs are completely transparent for end users \cite[p.~822]{computer-networks-tanenbaum-2012}.

\subsubsection{Wireless security}

It is very easy to design a system using VPNs and firewalls that is logically completely secure yet leaks like a sieve.
This happens if some machines use wireless and radio communication, which passes right over the firewall in both directions.
The range of 802.11 networks is often a few hundred meters, so unprotected wireless networks can be a major vulnerability \cite[p.~823]{computer-networks-tanenbaum-2012}.

Data link level security protocols such as WPA2 provide real security.
WEP and WPA are too weak and should no longer be used \cite[p.~824]{computer-networks-tanenbaum-2012}.

There are two scenarios in which WPA2 is used.

\textbf{In enterprise settings}, a separate authentication server can use provided username and passwords to determine if a wireless client is allowed to access the network.

\textbf{In personal settings}, there is no authentication server. Instead, there is a single shared password that is used by clients to access the network. This setup is much simpler, but it is also less secure. In this setup, a handshake is performed so that each client has two keys, one for direct communication with the access point (AP) and a key which is shared across all clients so that the AP can broadcast packages.

There are two protocols which dictate how these keys are actually used to provide security.
The first one was \textbf{TKIP}, which has been broken and should no longer be used.
The newer protocol is \textbf{CCMP}, which is based on 128-bit AES encryption. It is stronger and has not been broken yet \cite[p.~825]{computer-networks-tanenbaum-2012}.

\subsubsection{Bluetooth security}

Bluetooth has a shorter range than 802.11. However, it is also a possible vulnerability.
A Bluetooth keyboard output, for instance, could be sniffed to find out what someone was typing.
To establish a channel, the slave and master go through a pairing process, which may involve a passkey, for example.
After pairing, they negotiate whether that channel will be encrypted, integrity controlled, or both \cite[p.~827]{computer-networks-tanenbaum-2012}.

\section{Solved exercises}

\subsection{Solved course exercises}
\setcounter{Exercise}{0}

\begin{Exercise}
When the IPv6 protocol is introduced, does the ARP protocol have to be changed?
If so, are the changes conceptual or technical?
From \cite{computer-networks-tanenbaum-2012}.
\end{Exercise}
\begin{Answer}
Conceptually, there are no changes.
Technically, the IP addresses requested are now bigger, so bigger fields are needed.
It is worth noting that even though IPv6 does not support broadcast the same way as IPv4 did, you could use multicast to make a protocol very similar to ARP.
\end{Answer}

\begin{Exercise}
If one could use IP, ICMP, and ARP:
\begin{enumerate}
    \item How could one write a program so that they could determine whether an IP address was already in use or not?
    \item How could one determine the MTU of the network between point A and B?
    Would this always work? If not, when would it fail?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
    \item They could send an ARP request for this IP and see if any MAC address comes back.
    If one does, then that IP is already in use.
    \item One could set the \textit{don't fragment} (DF) bit in the IP headers of the outgoing packets and rely on the ICMP \textit{Fragmentation Needed} message to find out what the path MTU is. Any device along the path whose MTU is smaller than the packet the source host sent will drop it and send back a message containing its MTU, allowing the source host to reduce its MTU appropriately. The process is repeated until the MTU is small enough to traverse the entire path without fragmentation.

    No, it wouldn't always work. Many network security devices block all ICMP messages. This will also block the errors that are necessary for the proper operation of PMTUD.

    See \href{https://en.wikipedia.org/wiki/Path_MTU_Discovery}{Path MTU Discovery (PMTUD)}.
\end{enumerate}
\end{Answer}

\begin{Exercise}
Duplicate of exercise 25.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
Can an ARP table contain multiple entries for the same MAC associated with different IP addresses?
\end{Exercise}
\begin{Answer}
Yes, this can be a consequence of proxy ARP.
Multiple IP addresses may have been resolved to the MAC of the router.
\end{Answer}

\begin{Exercise}
A host in a network has the IP address 128.138.243.100 and the mask 255.255.255.192.
Find out the network number, the network broadcast address, the first and last valid IP addresses.
Assume a classful system. Seems to be taken from \cite{unix-system-administration-handbook-nemeth-2000}.
\end{Exercise}
\begin{Answer}
The logic and of 128.138.243.100 and 255.255.255.192 is 128.138.243.64, which is the network number.
As it is a /26, it has \(2^{32-26} - 2 = 2^{6} - 2 = 64 - 2 = 62\) hosts.

The network broadcast address is 128.138.243.127.

The first valid IP address is 128.138.243.65.

The last valid IP address is 128.138.243.126.

The \texttt{ipcalc 128.138.243.100/26} command produces the following output.

\small\begin{verbatim}
Address:   128.138.243.100      10000000.10001010.11110011.01 100100
Netmask:   255.255.255.192 = 26 11111111.11111111.11111111.11 000000
Wildcard:  0.0.0.63             00000000.00000000.00000000.00 111111
=>
Network:   128.138.243.64/26    10000000.10001010.11110011.01 000000
HostMin:   128.138.243.65       10000000.10001010.11110011.01 000001
HostMax:   128.138.243.126      10000000.10001010.11110011.01 111110
Broadcast: 128.138.243.127      10000000.10001010.11110011.01 111111
Hosts/Net: 62                   Class B
\end{verbatim}
\end{Answer}

\begin{Exercise}
Write down all you know about hubs, switches, and routers.
Mention technology, operation principle, bandwidth usage, broadcast domains, collision domains, and spanning trees.
\end{Exercise}
\begin{Answer}
Hubs operate on the physical layer, they just connect multiple lines as if they were the same single line. This is why they only define a single common collision domain.

Switches, on the other hand, define a single collision domain for each port as long as they have a full-duplex point-to-point connection. Switches, however, still define a single broadcast domain.
Switches operate on the second layer of the OSI stack, forwarding frames.
Switches are auto-configurable, in the sense that one could just plug one in and wander away, leaving it to configure itself. This works because algorithms such as the spanning three algorithm allow for switch to detect cycles and not propagate the same frames around forever.

Routers define a single broadcast domain per router interface. Routers operate on the third layer of the OSI stack, forwarding packets.
\end{Answer}

\begin{Exercise}
Determine the ARP sequence in the sending of a datagram, for the first time, from A (192.31.65.7) to B (192.31.62.8).
Specify for each message what are the source hardware address, the destination hardware address, the source IP address, and the destination IP address.
Both machines use a /24 mask. Is there any missing information?
\end{Exercise}
\begin{Answer}
It is missing whether there is a router between A and B, and whether or not this router does proxy ARP.
This is relevant because A and B are not in the same network and ARP requires broadcasts from the source machine to arrive at the destination machine.
Assuming there is a router R doing proxy ARP in the way, the sequence is as follows.

\begin{center}
\begin{tabular}{c|c|c|c}
    \(E_A\) & \(I_A\) &       0 & \(I_B\) \\
    \(E_R\) & \(I_R\) & \(E_A\) & \(I_A\) \\
\end{tabular}
\end{center}

If, instead, the router R were to just forward broadcasts, the sequence would be as follows.

\begin{center}
\begin{tabular}{c|c|c|c}
    \(E_A\) & \(I_A\) &       0 & \(I_B\) \\
    \(E_B\) & \(I_B\) & \(E_A\) & \(I_A\) \\
\end{tabular}
\end{center}
\end{Answer}

\begin{Exercise}
Explain the following routing algorithms and compare them with each other.
Which of these algorithms are related to static routing and which are related to dynamic routing?

\begin{enumerate}
    \item Shortest path (SP)
    \item Distance vector (DV)
    \item Link state (LS)
\end{enumerate}
\end{Exercise}
\begin{Answer}
SP is a static routing algorithm as it relies on calculating routes before the network is online.
It uses a graph algorithm such as Dijkstra's to find the shortest paths. See \ref{Shortest path algorithm}.

DV is a dynamic routing algorithm. One DV update works by inspecting the direct neighbors of the router being updated and setting the entries of its distance vector to the minimum possible combined cost of getting to the neighbor and cost to get to the destination from the neighbor. See \ref{Distance vector routing}.

LS is another dynamic routing algorithm. It works by allowing each router to know the entire topology of the network and then evaluating shortest paths from this knowledge. See \ref{Link state routing}.

Both DV and LS are much more sophisticated than SP as they can work automatically in existing networks, while SP is static and can not adapt on-the-fly to network topology changes.
DV has better scalability than LS because its complexity is proportional to the number of direct neighbors, which is usually limited by the number of network interfaces of the router, which is relatively small.
LS does not have the count-to-infinity problem which exists in DV. This problem causes DV to approach the value considered to be infinity just linearly. Therefore, it might take quite some time until all routers see that a previously existing route is no longer online. In DV, good news travel fast, but bad news travel slow.
\end{Answer}

\begin{Exercise}
A machine in a TCP/IP network has the IP address 143.54.13.100 and the network mask 255.255.255.192. What is the network number, the broadcast address of this network, the first and last valid IP addresses for hosts?
\end{Exercise}
\begin{Answer}
The network is 143.54.13.64/26. The broadcast address is 143.54.13.127 and the first and last valid IP addresses are 143.54.13.65 and 143.54.13.126, respectively.
\end{Answer}

\begin{Exercise}
You have 200.61.0.0/18. Distribute it between A, which needs 1800 addresses, B, which needs 800 addresses, and C, which needs 600 addresses.
\end{Exercise}
\begin{Answer}
A needs a /21, B and C need a /22.
A gets 200.61.0.0/21. B gets 200.61.8.0/22. C gets 200.61.12.0/22.
\end{Answer}

\begin{Exercise}
Assuming a network uses the distance vector routing algorithm, compute the new distance vector for router J.

\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
      & A & B & C & D & E & F & G & H & I & J & K & L \\ \hline
    A & 0 & 12 & 25 & 40 & 14 & 23 & 18 & 17 & 21 & 9 & 24 & 29 \\
    I & 24 & 36 & 18 & 27 & 7 & 20 & 31 & 20 & 0 & 11 & 22 & 33 \\
    H & 20 & 31 & 19 & 8 & 30 & 19 & 6 & 0 & 14 & 7 & 22 & 9 \\
    K & 21 & 28 & 36 & 24 & 22 & 40 & 31 & 19 & 22 & 10 & 0 & 9
\end{tabular}
\end{center}

Assume the following delays.

\begin{center}
\begin{tabular}{c|c|c}
    J & A &  8 ms \\
    J & I & 10 ms \\
    J & H & 12 ms \\
    J & K &  6 ms
\end{tabular}
\end{center}
\end{Exercise}
\begin{Answer}
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
      & A & B & C & D & E & F & G & H & I & J & K & L \\ \hline
    J & 8 & 20 & 28 & 20 & 17 & 30 & 18 & 12 & 10 & 16 & 6 & 15
\end{tabular}
\end{center}
\end{Answer}

\begin{Exercise}
Considering a 802.3 network, why can't the ARP protocol identify the MAC address of a machine in a different network?
Explain the solution using default gateways and the solution using ARP proxies.
\end{Exercise}

\begin{Exercise}
What is the maximum number of bits in the suffix of a class C IP network which can be used to define subnetworks?
\end{Exercise}
\begin{Answer}
Six.
Eight is clearly impossible as that would imply no bits for host identification.
Seven is also not possible because a network must have at least two hosts and two IP addresses are needed for the network address and network broadcast address, so we get that we must have at least 2 bits for the host to get a valid network.
\end{Answer}

\begin{Exercise}
Assume two hosts A and B desire to exchange the following messages over TCP.

\begin{enumerate}
\item A sends 50 bytes to B.
\item B sends 10 bytes to A.
\item A sends 20 bytes to B.
\item A sends 30 bytes to B.
\item B sends 90 bytes to A.
\item B sends 50 bytes to A.
\end{enumerate}

Assume A starts and also ends the connection. A proposes the sequence number 300 and B proposes the sequence number 100. Draw the message exchange with the SEQ value, the ACK value, and the flags used (SYN, ACK, FIN).
\end{Exercise}
\begin{Answer}

[SYN] SEQ = 300

\hspace*{\fill} [SYN, ACK] SEQ = 100, ACK = 301

[ACK] SEQ = 301, ACK = 101

\noindent\rule[0.5ex]{\linewidth}{1pt}

[PSH, ACK] SEQ = 301, ACK = 101

\hspace*{\fill} [ACK] SEQ = 101, ACK = 351

\noindent\rule[0.5ex]{\linewidth}{0.5pt}

\hspace*{\fill} [PSH, ACK] SEQ = 101, ACK = 351

[ACK] SEQ = 351, ACK = 111

\noindent\rule[0.5ex]{\linewidth}{0.5pt}

[PSH, ACK] SEQ = 351, ACK = 111

\hspace*{\fill} [ACK] SEQ = 111, ACK = 371

\noindent\rule[0.5ex]{\linewidth}{0.5pt}

[PSH, ACK] SEQ = 371, ACK = 111

\hspace*{\fill} [ACK] SEQ = 111, ACK = 401

\noindent\rule[0.5ex]{\linewidth}{0.5pt}

\hspace*{\fill} [PSH, ACK] SEQ = 111, ACK = 401

[ACK] SEQ = 401, ACK = 201

\noindent\rule[0.5ex]{\linewidth}{0.5pt}

\hspace*{\fill} [PSH, ACK] SEQ = 201, ACK = 401

[ACK] SEQ = 401, ACK = 251

\noindent\rule[0.5ex]{\linewidth}{1pt}

[FIN, ACK] SEQ = 401, ACK = 251

\hspace*{\fill} [ACK] SEQ = 251, ACK = 402

\hspace*{\fill} [FIN, ACK] SEQ = 251, ACK = 402

[ACK] SEQ = 402, ACK = 252

Answered according to \cite{computer-networking-kurose-2012} and according to an experiment using Python and Wireshark.
\end{Answer}

\begin{Exercise}
Explain how a client host can find a server process in another machine using TCP/IP. Is it any different when using UDP/IP?
\end{Exercise}
\begin{Answer}
IP is used to find the other host, then the port information will be used to specify which process on that machine will handle the requests.
Using TCP/IP, the server process will be listening for new connections in a given port. Using UDP/IP the server process will be listening to all datagrams coming into a given port.
Therefore, there is no difference in regard to how the host and process is determined.
\end{Answer}

\begin{Exercise}
\begin{enumerate}
\item Regarding network layer fragmentation, why is the reassembly done at the endpoint and not in intermediary nodes?
\item If the reassembly was done in the intermediary nodes, which impact would this have for network services which are not connection-oriented?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item If reassembly happened in the intermediary nodes, fragmentation likely would have to happen again in order to reach the receiving endpoint, resulting in more packet reassembly for the next intermediary nodes. Because of this, in the the Internet only fragmentation happens and the receiving endpoint performs reassembly. See \ref{Packet fragmentation}.
\item It would remove the need for the code and processing time required to perform reassembly at the end system.
\end{enumerate}
\end{Answer}

\begin{Exercise}
Compare distance vector routing algorithms with link state routing algorithms.
\begin{enumerate}
\item What information they exchange?
\item How much data they have to exchange?
\item How is routing done?
\item Are there any convergence problems?
\end{enumerate}
Mention protocols which use these algorithms.
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item What information they exchange?

Distance vector algorithms require routers to exchange distance vectors, which contain the estimated cost to go from a router to each of its direct neighbors.

Link state algorithms also make routers exchange information about their direct neighbors, but this information has to be sent to all other routers, not only to the router's direct neighbors.

\item How much data they have to exchange?

The amount of data exchanged in distance vector routing algorithms is directly proportional to the number of neighbors the routers have, while the amount of data exchanged in link state routing algorithms is directly proportional to the number of routers in the whole network and the number of neighbors the routers have.

\item How is routing done?

Routing in distance vector routing algorithms is done by calculating the new distance vector based on the latency to the direct neighbors and the vectors sent in by these neighbors.
In link state routing algorithms, routing is done by running a shortest paths graph algorithm such as Dijkstra's to find out the optimal paths to each router.

\item Are there any convergence problems?

Yes. Distance vector routing algorithms have very slow convergence to detect a router failure. Distance vector routing algorithms react quickly to network latency improvements, but very slowly to network fragmentation.
\end{enumerate}

RIP is a distance vector routing algorithm. OSPF and IS-IS are link state routing (LSR) algorithms.

See \ref{Distance vector routing} and \ref{Link state routing} for more.
\end{Answer}

\begin{Exercise}
Duplicate of exercise 13.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
Duplicate of exercise 17.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\begin{enumerate}
\item Why TCP uses three-way handshakes instead of two-way handshakes?
\item Describe the T-PDUs exchanged when connections are terminated symmetrically, asymmetically, and abruptly.
\item What is TSAP?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item TCP requires both parties to establish their sequence numbers. As the initial sequence number of the receiving host also has to be acknowledged, a third message is required.
Additionally, by sending a third message from A to B, B knows that there is a path through which A can receive messages from B.
\item \textbf{Symmetrically}, the entity which desires to close the connection will send a FIN and wait for the other side to send any data it still has to transmit and a FIN. \textbf{Asymmetrically}, the entity which desires to close the connection will send a FIN message and close the connection. \textbf{Abruptly}, just a RST is sent.
\item A TSAP (transport service access point) is a specific endpoint in the transport layer. A TSAP identifies an instance of a service.
An NSAP (network service access point) only specifies a host, the TSAP is needed to specify a process running on that specific host.
An IP address is an example of an NSAP, whereas an IP address and port number pair is an example of a TSAP.
\end{enumerate}
\end{Answer}

\begin{Exercise}
What is the maximum number of bits in a suffix that can be used to define subnetworks in an IP network?
\end{Exercise}
\begin{Answer}
If the suffix has \(n\) bits, then it is \(n - 2\).
It is \(n - 2\) because the host part must have at least two bits for it to be a valid network.
See exercise 13 to understand why.
\end{Answer}

\begin{Exercise}
What is CIDR? How does it help solve the IPv4 addresses exhaustion?
Give an example of CIDR block allocation.
What is meant by least and most restrictive masks?
\end{Exercise}
\begin{Answer}
CIDR is a design for dividing networks in a classless manner.
It helps with IPv4 address exhaustion by allowing for networks of sizes other than \(2^{8}\), \(2^{16}\) and \(2^{24}\).

Given the 220.100.0.0/16 network, it can be further subdivided into 220.100.0.0/17, 220.100.128.0/18, and 220.100.192.0/18 assuming that we can use the all-zeros and all-ones sub-networks.

The most restrictive mask is the longest mask. It has the highest priority.
The least restrictive mask is the shortest mask. It has the least priority.
\end{Answer}

\begin{Exercise}
Duplicate of exercise 21.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
What is proxy ARP? How does it work? What alternatives are there to it?
\end{Exercise}
\begin{Answer}
Proxy ARP is used to make a host appear in a network even though it is in another network.
It works with the help from routers, as normally Ethernet-level broadcasts are not forwarded by routers.
The router has to reply to the ARP request with \textbf{its own Ethernet address}.
Then the sender host can send frames which are meant to the receiver host \textbf{to the router}, which will then forward these frames to the correct device.
To the sender it all happens transparently as if the receiver was in the same network.
It allows for machines on a sub-network to reach remote sub-networks without the need to configure routing or a default gateway.

An alternative to it is to go straight for routing. Instead of the router faking that it has the requested IP, it just does not respond to the ARP request and the device -- assuming it has been correctly configured -- will have to send frames explicitly to its default gateway, which will then forward the packets to their true destination.
\end{Answer}

\begin{Exercise}
Why does the duration of a segment (time to live) has to be long enough to ensure that not only the segment but also all of its acknowledgements have disappeared from the network?
How can this affect the establishment of a connection and the data transfer phase?
\end{Exercise}
\begin{Answer}
If the TCP initial sequence number did not have a time to live, an acknowledge which still exists in the network might end up acknowledging a newer message, messing up the exchange protocols.

During connection establishment, an acknowledge of an old connection can end up acknowledging this new connection, which will cause synchronization issues.

During data transfer, an old acknowledge might end up acknowledging data that was not received, making the sender step forward and causing it to never resend data that it should resend.
\end{Answer}

\begin{Exercise}
The fragmentation and reassembly of IP datagrams is a responsibility of the network layer, does this mean that the TCP stack does not have to care about ordering?
\end{Exercise}
\begin{Answer}
No. IP only guarantees packets to be assembled correctly. They might still be dropped and delivered in the wrong order.
Therefore, the TCP stack has to be aware of which packets have been delivered and in which order they should be placed.
\end{Answer}

\begin{Exercise}
A router has the following entries on its routing table:

\begin{center}
\begin{tabular}{c|c|c}
    Destination network & Mask          & Next hop    \\ \hline
            135.46.56.0 & 255.255.252.0 & Interface 0 \\ \hline
            135.46.60.0 & 255.255.252.0 & Interface 1 \\ \hline
            192.53.40.0 & 255.255.254.0 & Interface 2 \\ \hline
            Default     &       0.0.0.0 & Interface 3
\end{tabular}
\end{center}

Determine the next hop for datagrams addressed to the following addresses.

\begin{enumerate}
\item 135.46.63.10
\item 135.46.57.14
\item 135.46.52.2
\item 192.53.40.7
\item 192.53.56.7
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item 135.46.63.10 \& 255.255.254.0 = 135.46.62.0. No match for this prefix size.

135.46.63.10 \& 255.255.252.0 = 135.46.60.0. \textbf{Matches interface 1}.

\item 135.46.57.14 \& 255.255.254.0 = 135.46.56.0. No match for this prefix size.

135.46.57.14 \& 255.255.252.0 = 135.46.56.0. \textbf{Matches interface 0}.

\item 135.46.52.2 \& 255.255.254.0 = 135.46.52.0. No match for this prefix size.

135.46.52.2 \& 255.255.252.0 = 135.46.52.0. No match for this prefix size.

135.46.52.2 \& 0.0.0.0 = 0.0.0.0. \textbf{Matches interface 3}.

\item 192.53.40.7 \& 255.255.254.0 = 192.53.40.0. \textbf{Matches interface 2}.

\item 192.53.56.7 \& 255.255.254.0 = 192.53.56.0. No match for this prefix size.

192.53.56.7 \& 255.255.252.0 = 192.53.56.0. No match for this prefix size.

192.53.56.7 \& 0.0.0.0 = 0.0.0.0. \textbf{Matches interface 3}.
\end{enumerate}
\end{Answer}

\begin{Exercise}
Why link state routing requires both sequence numbers and age in its PDUs?
\end{Exercise}
\begin{Answer}
The sequence number is important for the routers to know whether a PDU has to be discarded (because it is an older PDU or a duplicate of the newest PDU) or kept.
However, just using a sequence number can cause major issues if a router is restarted, as all of its first PDUs will be ignored for having a lower sequence number.
Therefore, an age field is also used. Eventually, the stale information about the restarted router will be discarded and new PDUs (even if they have a much lower sequence number) will be accepted.

An age field also mitigates the risk of data corruption affecting the PDU sequence number. A bit flip could increase the PDU sequence number substantially, which would cause many updates to be ignored if existing values were not subject to aging.

If only the age field were to be used, the flood would not be stopped by the detection of repeated PDUs, which could lead to a substantial waste of bandwidth.
\end{Answer}

\begin{Exercise}
Requires a drawing.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
Which problems of the distance vector algorithm are solved by the link state algorithm?
\end{Exercise}
\begin{Answer}
The count-to-infinity problem, which is why the distance vector may take a very long time to notice that a node is unreachable, is solved because now at every synchronization the whole topology of the network is sent to each node.
\end{Answer}

\begin{Exercise}
Which network parameters have to be correctly configured in a computer for it to have network access to external networks?
\end{Exercise}
\begin{Answer}
The default gateway, which is required for the computer to know where to send packets to in order to get them forwarded to the destination.
Possibly also the DNS servers, which are required for the computer to resolve names.
\end{Answer}

\begin{Exercise}
Why do personal computers have a routing table if they usually only have one network interface?
\end{Exercise}
% TODO: review.
\begin{Answer}
Because personal computers also have to know what is their default gateway, an information which is stored in the routing tables as the destination of a default entry.
\end{Answer}

\begin{Exercise}
Why is UDP necessary if it doesn't provide any more delivery guarantees than IP does?
\end{Exercise}
\begin{Answer}
Even though UDP does not offer more delivery guarantees than IP does, UDP has the very important concept of ports, thus allowing for transport-layer multiplexing and demultiplexing.
This makes it simpler for two services to be provided by the same host as if they were not sharing network resources between themselves.
Without the concept of ports, IP packet multiplexing and demultiplexing would have to happen in the application layer, which would mean that an application would have to get all IP packets and then decide how to distribute them to all other applications.
\end{Answer}

\begin{Exercise}
Provide a firewall rule to block all external hosts from opening TCP connections to machines which are in the internal network.
Consider that the internal network is 200.20.20.0/24.
\end{Exercise}
\begin{Answer}
\begin{verbatim}
Source IP  Destination IP  Source port  Destination port  Flags
*          200.20.20.*     *            *                 SYN
\end{verbatim}
\end{Answer}

\begin{Exercise}
A network administrator has to subdivide 200.30.40.0/24 in five sub-networks.
Perform this division considering a classless scheme and provide the broadcast addresses.
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item 200.30.40.0/27, 200.30.40.31
\item 200.30.40.32/27, 200.30.40.63
\item 200.30.40.64/27, 200.30.40.95
\item 200.30.40.96/27, 200.30.40.127
\item 200.30.40.128/27, 200.30.40.159
\end{enumerate}
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
What is the reason for the active FTP protocol? Which problem does it solve?
\end{Exercise}
\begin{Answer}
The biggest issue of FTP passive mode is the need to allow any remote connection to high numbered ports on the server. Active FTP allows the server to only use the port 20 as the data port, which may simplify firewall rules on the server side.
\end{Answer}

\begin{Exercise}
What are the two most important features of the network layer in a datagram network such as IP?
\end{Exercise}
\begin{Answer}
The two most important features are packet forwarding (the transfer of a packet from an incoming link to an outgoing link at a single router) and packet routing (finding a path from the source to the destination) \cite[p.~305]{computer-networking-kurose-2012}.
\end{Answer}

\begin{Exercise}
In link state routing, how the routers determine whether a link state packet has already been seen?
\end{Exercise}
\begin{Answer}
The packets include a sequence number. If the sequence number of a new packet coming from another router is lower than the highest already seen from that router it is discarded because that router already sent newer data. If it is a duplicate, it is also discarded. If it is the new highest sequence number for that router, it is forwarded on all lines except the one it arrived on \cite[p.~376]{computer-networks-tanenbaum-2012}.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
What is the difference between message confidentiality and message integrity? Can you have one without the other?
\end{Exercise}
\begin{Answer}
\textbf{Message confidentiality} is the property that the original message can not be obtained by an attacker who intercepts the ciphertext of the original message.
\textbf{Message integrity} is the property that the receiver can detect whether the message sent was altered in transit.

The two are different concepts and it is possible to have one without the other.

An encrypted message that is mangled in a way that the receiver cannot detect will still have \textbf{message confidentiality}.
Similarly, a message that is sent in plaintext could have \textbf{message integrity} despite it not being confidential.
\end{Answer}

\begin{Exercise}
Consider the Internet and its different protocols. A MUA sends a message to an e-mail server within its own domain. The client and the server are in the same subnet and both are with all network parameters properly configured. List, in order, which (network, transport, and application) protocols will be captured by a sniffer and what they do when used. Ignore caching.
\end{Exercise}
\begin{Answer}
DNS resolution will require DNS, which uses UDP over IP.
SMTP will require SMTP, which uses TCP over IP.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
A network administrator needs to divide the address block 10.1.2.0/24 into five sub-networks.
Determine, for both classful (avoiding all-zeros and all-ones sub-networks) and classless sub-netting, the network mask, the first host address, the last host addresses, and the broadcast address of the sub-networks.
\end{Exercise}
\begin{Answer}
We need 5 networks, so 3 bits are needed for both classful and classless subdivisions.

Using classful we have the following.
\begin{enumerate}
\item 10.1.2.32/27, 10.1.2.33, 10.1.2.62, 10.1.2.63
\item 10.1.2.64/27, 10.1.2.65, 10.1.2.94, 10.1.2.95
\item 10.1.2.96/27, 10.1.2.97, 10.1.2.126, 10.1.2.127
\item 10.1.2.128/27, 10.1.2.129, 10.1.2.158, 10.1.2.159
\item 10.1.2.160/27, 10.1.2.161, 10.1.2.190, 10.1.2.191
\end{enumerate}

Using classless we have the following.
\begin{enumerate}
\item 10.1.2.0/27, 10.1.2.1, 10.1.2.30, 10.1.2.31
\item 10.1.2.32/27, 10.1.2.33, 10.1.2.62, 10.1.2.63
\item 10.1.2.64/27, 10.1.2.65, 10.1.2.94, 10.1.2.95
\item 10.1.2.96/27, 10.1.2.97, 10.1.2.126, 10.1.2.127
\item 10.1.2.128/27, 10.1.2.129, 10.1.2.158, 10.1.2.159
\end{enumerate}
\end{Answer}

\begin{Exercise}
An analyst has to publish a document.
However, it is important to prevent that the document is altered by third parties and then disseminated.
\begin{enumerate}
\item Which information security properties have to be preserved?
\item Which solution could be used?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item Integrity, authenticity, and non-repudiation.
\item A public-key signature would be perfect.

By providing a signature which can only be generated by who has the private key of the asymmetrical key pair, the analyst would ensure that it would be statistically unlikely for one to guess the correct signature for an altered version of the document, assuming the private key wasn't compromised.

A public-key signature also guarantees non-repudiation because, if we assume that the private key has not been leaked, only the owner of the private key could have signed the document.
\end{enumerate}
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
Assuming a process offers a service X on port Y, using UDP.
\begin{enumerate}[a)]
\item Can another process offer X in a different port, also using UDP?
\item Can another process offer X in the same port Y when using UDP?
\item Can another process offer X in the same port Y when using TCP?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}[a)]
\item Absolutely.
\item In principle, no, if they are trying to use different sockets.
However, one could fork a process which owned a socket to port Y and then get two processes which have access to port Y using the same UDP socket.
Additionally, some modern operating systems allow multiple sockets to be bound to the same UDP port. For instance, Linux (since version 3.9) supports this through the option \texttt{SO\_REUSEPORT}. More about this can be found \href{http://man7.org/linux/man-pages/man7/socket.7.html}{in the documentation}.
\item Yes, UDP and TCP ports of the same number are different ports.
\end{enumerate}
\end{Answer}

\begin{Exercise}
Why and when does SSL use asymmetric and symmetric cryptography?
\end{Exercise}
\begin{Answer}
The server sends a copy of its public key to the client, which then generates a session key and uses this public key to encrypt it and send it to the server.
The server decrypts the encrypted session key using its private key.
After this exchange, both server and client will use symmetric key cryptography to exchange messages.

The main reason for doing this is that symmetric key cryptography algorithms have much higher throughput than asymmetric key cryptography algorithms.
\end{Answer}

\begin{Exercise}
A corporation has the following three IPv4 blocks.
\begin{enumerate}
\item 150.10.0.0/19
\item 150.10.32.0/19
\item 150.10.96.0/19
\end{enumerate}
Can they be aggregated?
If not, determine which blocks are missing and what the aggregated block address would be.
\end{Exercise}
\begin{Answer}
No, they cannot. 150.10.64.0/19 is missing to make 150.10.0.0/17.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
An institution has the Class C address 200.10.10.0.
This institution needs seven networks with 10, 5, 8, 12, 7, 9, and 4 hosts.
What is the network mask to be used?
List the network addresses, their broadcast address and the valid IP ranges for hosts.
\end{Exercise}
\begin{Answer}
The institution needs 7 networks of less than 15 hosts, so networks of 14 hosts suffice. A class C block has (under classful allocation), \(2^{4} - 2 = 14\) of such networks.

Therefore, the mask is 255.255.255.240.

\begin{itemize}
\item 200.10.10.16, 200.10.10.31, 200.10.10.17 -- 200.10.10.30
\item 200.10.10.32, 200.10.10.47, 200.10.10.33 -- 200.10.10.46
\item 200.10.10.48, 200.10.10.63, 200.10.10.49 -- 200.10.10.62
\item 200.10.10.64, 200.10.10.79, 200.10.10.65 -- 200.10.10.78
\item 200.10.10.80, 200.10.10.95, 200.10.10.81 -- 200.10.10.94
\item 200.10.10.96, 200.10.10.111, 200.10.10.97 -- 200.10.10.110
\item 200.10.10.112, 200.10.10.127, 200.10.10.113 -- 200.10.10.126
\end{itemize}

See \href{https://www.cisco.com/c/en/us/support/docs/ip/dynamic-address-allocation-resolution/13711-40.html}{the relevant Cisco document} and \href{https://tools.ietf.org/html/rfc950}{RFC 950}.
\end{Answer}

\begin{Exercise}
An institution has a block of 4096 addresses.
This block was subdivided in 2 blocks of 1024 addresses and 4 blocks of 512 addresses.
Identify the block and all sub-networks knowing that 192.168.2.5 and 192.168.4.1 belong to different blocks of 1024 addresses and that 192.168.9.20, 192.168.10.1, 192.168.12.1 e 192.168.15.50 belong to different blocks of 512 addresses.
\end{Exercise}
\begin{Answer}
\begin{itemize}
\item The logical and of 192.168.2.5 and 255.255.252.0 is 192.168.0.0.
\item The logical and of 192.168.4.1 and 255.255.252.0 is 192.168.4.0.
\item The logical and of 192.168.9.20 and 255.255.254.0 is 192.168.8.0.
\item The logical and of 192.168.10.1 and 255.255.254.0 is 192.168.10.0.
\item The logical and of 192.168.12.1 and 255.255.254.0 is 192.168.12.0.
\item The logical and of 192.168.15.50 and 255.255.254.0 is 192.168.14.0.
\end{itemize}
Therefore, the original block was 192.168.0.0/20.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
A router supports classless routing and has the following routing table.

\begin{center}
\begin{tabular}{c c c}
    Destination network & Next hop   & Mask            \\ \hline
           150.100.92.1 & 200.10.1.1 & 255.255.255.255 \\ \hline
           150.100.80.0 & 192.10.2.1 & 255.255.240.0   \\ \hline
           150.100.64.0 & 192.10.2.2 & 255.255.192.0   \\ \hline
                Default & 200.10.1.2 & 0.0.0.0
\end{tabular}
\end{center}

List all possible routes and the selected routes for datagrams to following addresses.
\begin{enumerate}
\item 150.100.92.1
\item 150.100.94.1
\item 150.100.128.1
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item 150.100.92.1 \& 255.255.255.255 = 150.100.92.1. Possible. \textbf{Selected 200.10.1.1}.
\item 150.100.94.1 \& 255.255.255.255 = 150.100.94.1. Not possible.

150.100.94.1 \& 255.255.240.0 = 150.100.80.0. Possible. \textbf{Selected 192.10.2.1}.

\item 150.100.128.1 \& 255.255.255.255 = 150.100.128.1. Not possible.

150.100.128.1 \& 255.255.240.0 = 150.100.128.0. Not possible.

150.100.128.1 \& 255.255.192.0 = 150.100.128.0. Not possible.

150.100.128.1 \& 0.0.0.0 = 0.0.0.0. Possible. \textbf{Selected 200.10.1.2}.
\end{enumerate}
\end{Answer}

\begin{Exercise}
Duplicate of exercise 60.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
Two users A and B want to communicate over the public Internet with confidentiality.
\begin{enumerate}[a)]
\item Can they use symmetric cryptography? What about asymmetric cryptography?
\item For each possible case, which keys are present?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}[a)]
\item Both symmetric and asymmetric cryptography can be used.
\item When using symmetric cryptography, the users must have a shared secret key. When using asymmetric cryptography, both users need a public and a private key.
When sending a message, the sender will use the receiver's public key to encrypt it in such a way that only the receiver -- who has the private key -- can reverse the process.
\end{enumerate}
\end{Answer}

\begin{Exercise}
An institution has 5000 hosts uniformly distributed over 100 networks.
Propose a CIDR and a classful allocation scheme and compare the amount of wasted addresses.
\end{Exercise}
\begin{Answer}
There are 100 networks of 50 hosts each. Therefore, 62-host networks are enough.
The most efficient uniform distribution is to have 128 networks of 62-hosts.
This requires \(7 + 6 = 13\) bits for the network and host parts.
Therefore, a block with \(2^{13} = 8192\) addresses will be needed.
The occupancy then is \(5000 / 8192 \approx 0.61035\).

Using a Class B network, there would be \(2^{16}\) available addresses.
Then the occupancy would be \(5000 / 65536 \approx 0.07629\).
\end{Answer}

\begin{Exercise}
The HTTP protocol supports non-persistent and persistent connections.
Multiple non-persistent connections can be established in parallel.
Persistent connection may use request pipelining.

Assuming a web page references other 15 objects and that the client cannot open an infinite number of connections.

How many connections are established, at least, by a client employing the following techniques?

\begin{enumerate}[a)]
\item A single non-persistent connection.
\item Parallel non-persistent connections.
\item Persistent connections without pipelining.
\item Persistent connections with pipelining.
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}[a)]
\item There are 16 connections. One at a time.
\item There are 16 connections. Even if done in parallel, one connection gets one object.
\item Assuming that the server does not close the connection, 1 connection suffices.
\item Assuming that the server does not close the connection, 1 connection suffices.
\end{enumerate}

\end{Answer}

\begin{Exercise}
Duplicate of exercise 61.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
A router has the following routing table. For each of the following datagrams list all possible routes and the selected route.

\begin{center}
\begin{tabular}{c c c}
    Destination network & Next hop   & Mask            \\ \hline
           195.112.92.1 & 200.10.1.1 & 255.255.255.255 \\ \hline
           195.112.80.0 & 192.10.2.1 & 255.255.240.0   \\ \hline
           195.112.64.0 & 192.10.2.2 & 255.255.192.0   \\ \hline
                Default & 200.10.1.2 & 0.0.0.0
\end{tabular}
\end{center}

\begin{enumerate}
    \item 195.112.92.1
    \item 195.112.94.1
    \item 195.112.96.1
    \item 195.112.130.1
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
    \item 195.112.92.1 \& 255.255.255.255 = 195.112.92.1. Possible. \textbf{Selected}.

    195.112.92.1 \& 255.255.240.0 = 195.112.80.0. Possible.

    195.112.92.1 \& 255.255.192.0 = 195.112.64.0. Possible.

    195.112.92.1 \& 0.0.0.0 = 0.0.0.0. Possible.

    \item 195.112.94.1 \& 255.255.255.255 = 195.112.94.1. Not possible.

    195.112.94.1 \& 255.255.240.0 = 195.112.80.0. Possible. \textbf{Selected}.

    195.112.94.1 \& 255.255.192.0 = 195.112.64.0. Possible.

    195.112.94.1 \& 0.0.0.0 = 0.0.0.0. Possible.

    \item 195.112.96.1 \& 255.255.255.255 = 195.112.96.1. Not possible.

    195.112.96.1 \& 255.255.240.0 = 195.112.96.0. Not possible.

    195.112.96.1 \& 255.255.192.0 = 195.112.64.0. Possible. \textbf{Selected}.

    195.112.96.1 \& 0.0.0.0 = 0.0.0.0. Possible.

    \item 195.112.130.1 \& 255.255.255.255 = 195.112.130.1. Not possible.

    195.112.130.1 \& 255.255.240.0 = 195.112.128.0. Not possible.

    195.112.130.1 \& 255.255.192.0 = 195.112.128.0. Not possible.

    195.112.130.1 \& 0.0.0.0 = 0.0.0.0. Possible. \textbf{Selected}.
\end{enumerate}
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
What is the prefix and the most restrictive mask for an IP network in which a server has the address 192.168.1.5 and the single router has the address 192.168.2.1?
\end{Exercise}
\begin{Answer}
We need to allow the last 10 bits for the host to uniquely identify machines in this network.
So 10 bits, making the mask 255.255.252.0.
\end{Answer}

\begin{Exercise}
An organization has the following networks.
\begin{enumerate}
    \item 200.10.0.0/26
    \item 200.10.0.64/26
    \item 200.10.0.128/26
    \item 200.10.0.192/26
    \item 200.10.1.0/26
    \item 200.10.1.64/26
    \item 200.10.1.128/25
\end{enumerate}
What is the address block allocated to the institution?
\end{Exercise}
\begin{Answer}
200.10.0.0/23.
\end{Answer}

\begin{Exercise}
An user downloads files from a remote FTP server.
Assuming there is no cached information, list all protocols used to accomplish this, in the order they are requested.
\end{Exercise}
\begin{Answer}
The user tries to use FTP at the application layer to connect to the server.
In order to know the IP address of the server, another application layer protocol, DNS, has to be used. DNS is built on top of UDP, which is built on top of IP.
Once the name has been resolved, FTP can start being used and call onto the TCP stack, which is itself is built on top of IP.
\end{Answer}

\begin{Exercise}
What are the advantages of hierarchical routing for the routing process?
\end{Exercise}
\begin{Answer}
For the routing process, hierarchical routing reduces routing table size, which greatly impacts routing performance.
Keeping very large routing tables, even if they fit in memory, means that more bandwidth will be used when running the routing algorithms to synchronize routing tables between routers.

It is also worth noting that in large networks, hierarchical routing allows each region to use whatever routing algorithm is best for it.
If there weren't multiple hierarchical levels for routing, every router in the whole network would have to use the same routing algorithm.

See \ref{Distance vector routing}, \ref{Link state routing}, and \ref{Hierarchical routing} for more.
\end{Answer}

\begin{Exercise}
An ISP has the 195.168.0.0/16 block. Divide it in three blocks of 30 addresses, one block of 62 addresses, and two blocks of 126 addresses.
\end{Exercise}
\begin{Answer}
\begin{enumerate}
    \item 195.168.0.0/27
    \item 195.168.0.32/27
    \item 195.168.0.64/27
    \item 195.168.0.128/26
    \item 195.168.1.0/25
    \item 195.168.1.128/25
\end{enumerate}

An illustrative table of the division follows.

\begin{center}
\begin{tabular}{r r c}
          Prefix size &                First address & Used                               \\ \hline
                   27 &                  195.168.0.0 & \checkmark                         \\ \hline
                   27 &                 195.168.0.32 & \checkmark                         \\ \hline
                   27 &                 195.168.0.64 & \checkmark                         \\ \hline
                   27 &                 195.168.0.96 &                                    \\ \hline
    \multirow{2}*{26} & \multirow{2}*{195.168.0.128} & \multirow{2}*{\checkmark}       \\ \\ \hline
    \multirow{2}*{26} & \multirow{2}*{195.168.0.192} & \multirow{2}*{}                 \\ \\ \hline
    \multirow{4}*{25} & \multirow{4}*{  195.168.1.0} & \multirow{4}*{\checkmark} \\ \\ \\ \\ \hline
    \multirow{4}*{25} & \multirow{4}*{195.168.1.128} & \multirow{4}*{\checkmark} \\ \\ \\ \\ \hline
\end{tabular}
\end{center}
\end{Answer}

\begin{Exercise}
A network administrator is trying to identify which services are being offered by a certain machine. The output of \texttt{netstat -tuan} is as follows.

\begin{verbatim}
Proto Recv-Q  Send-Q Local Address   Foreign Address     State
tcp      0       0   0.0.0.0:25      0.0.0.0:*           LISTEN
tcp      0       0   0.0.0.0:80      0.0.0.0:*           LISTEN
tcp      0       0   192.10.1.33:21  0.0.0.0:*           LISTEN
tcp      0       0   192.10.1.65:25  192.10.1.1:55120    ESTABLISHED
tcp      0       0   192.10.1.33:21  200.20.1.1:63472    ESTABLISHED
tcp      0       0   192.10.1.65:80  150.10.50.1:54387   ESTABLISHED
udp      0       0   0.0.0.0:7       0.0.0.0:*
udp      0       0   192.10.1.97:53  0.0.0.0:*
\end{verbatim}

\begin{enumerate}
\item How many services are running on this machine?
Which transport protocols are being used by these services?
How many services of each type of protocol exist?
\item Which sockets are waiting new connection requests?
\item How many clients are using the services right now?
\item Are the IP addresses of this machine shown? If so, what are they?
\item This machine received a SYN segment whose source and destination ports are 55120 and 25. Which socket is this segment using?
\item The UDP sockets are not in any state. Is this a problem?
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item Five services. Three using TCP and two using UDP.
\item The first three ones (TCP and listening).
\item At least three, because there are at least three established TCP connections. It is not possible to determine the number of UDP clients.
\item At least three of this machine IP addresses are shown as the bound to address of a few sockets. They are 192.10.1.33, 192.10.1.65, 192.10.1.97.
\item It went to the fourth socket, which is established to 192.10.1.1:55120.
\item No. UDP sockets do not have the notion of state.
\end{enumerate}
\end{Answer}

\begin{Exercise}
In a Windows XP machine, the command \texttt{netstat -na} presented the following result, explain it.

\texttt{TCP 127.0.0.1:2222 0.0.0.0:* LISTENING}
\end{Exercise}
\begin{Answer}
There is a TCP socket listening on port 2222 for connections from any address and any port.
\end{Answer}

\begin{Exercise}
When dividing the IP address range 200.30.40.0 with a /24 mask in seven sub-networks, is there any difference between a classful and a classless design?
If so, which network parameters are affected?
\end{Exercise}
\begin{Answer}
There is. In a classful network which complies to RFC 950, the sub-network zero and the all-ones sub-network have to be avoided.
Therefore, in order to get 7 sub-networks, a classful design will require 4 bits for the network portion while a classless design could use just 3 bits for the network portion.
The affected network parameter is the sub-network mask.
\end{Answer}

\begin{Exercise}
Duplicate of exercise 11.
\end{Exercise}
\begin{Answer}
None.
\end{Answer}

\begin{Exercise}
Assume that a machine has infinite processing capacity and infinite memory.
What would be the maximum theoretical number of TCP connections established at the same time of this machine?
\end{Exercise}
\begin{Answer}
Because each TCP connection identifier consists of (source IP address, source port, destination IP address, destination port), \textbf{assuming we can use all IPv4 addresses}, we would have \(\left(2^{16} \cdot 2^{32} \cdot 2^{16}\right) n = \left(2^{64}\right) n\) possible TCP connections to this machine, where \(n\) is the number of IP addresses this machine can listen on.

\begin{displayquote}
A TCP port plus its host's IP address forms a 48-bit unique end point.
The source and destination end points together identify the connection.
\cite[p.~557]{computer-networks-tanenbaum-2012}
\end{displayquote}
\end{Answer}

\begin{Exercise}
What advantages do autonomous systems bring to the routing process?
\end{Exercise}
\begin{Answer}
% Review.
The main advantages that autonomous systems bring to the routing process are intradomain routing freedom (intradomain routing can be done however deemed adequate) and a reduction of the number of systems visible for inter-domain routing.
\end{Answer}

\begin{Exercise}
A corporation has the block 192.50.32.0/19.
It has to be divided in 14 sub-networks, according to the following valid host IP address requirements.
Propose an allocation scheme.
\begin{enumerate}
\item N1 - 800
\item N2, N3 - 400
\item N4 - 350
\item N5, N6 - 200
\item N7, N8, N9, N10, N11 - 100
\item N12, N13, N14 - 80
\end{enumerate}
\end{Exercise}
\begin{Answer}
\begin{enumerate}
\item N1 - 192.50.32.0/22
\item N2 - 192.50.36.0/23
\item N3 - 192.50.38.0/23
\item N4 - 192.50.40.0/23
\item N5 - 192.50.42.0/24
\item N6 - 192.50.43.0/24
\item N7 - 192.50.44.0/25
\item N8 - 192.50.44.128/25
\item N9 - 192.50.45.0/25
\item N10 - 192.50.45.128/25
\item N11 - 192.50.46.0/25
\item N12 - 192.50.46.128/25
\item N13 - 192.50.47.0/25
\item N14 - 192.50.47.128/25
\end{enumerate}

\end{Answer}

\begin{Exercise}
UDP only uses the destination port to demultiplex the received datagrams.
TCP, on the other hand, uses a pair of endpoints.
Why can't TCP only use the destination port?
\end{Exercise}
\begin{Answer}
The reason why TCP can't use only the destination port is that UDP datagrams are addressed to a host and port, while TCP datagrams belong to a connection identified also by the source host and source port.
Therefore, if only the destination port was used to demultiplex TCP datagrams and two connections were established using the same destination port, traffic from both connections would be mixed.
% Review.
\end{Answer}

\begin{Exercise}
What are autonomous systems?
What is the main reason for their creation?
How are they used in the Internet?
\end{Exercise}
\begin{Answer}
An AS is a portion of a network that is under another administrative authority.
The main reason for their creation was to decentralize the network, providing both hierarchy and freedom for choosing whichever internal routing protocol (IRP) the responsible authority wanted to use.
In the Internet, generally ISPs have their own autonomous systems, which they route internally however they deem appropriate and externally using BGP, which is the external routing protocol (ERP) of the Internet.
\end{Answer}

\begin{Exercise}
What problem could arise if TCP connections always started with the sequence number zero?
\end{Exercise}
\begin{Answer}
The main problem is that a segment which is still present in the network from a previous connection between two hosts might be mistaken for a valid segment in a new connection between these two hosts if they happen to be using the same ports.
Using a random or monotonically increasing segment sequence number greatly reduces the risk of this happening \cite[p.~236]{computer-networking-kurose-2012}.

Another problem is that attacks based on sequence number spoofing are possible in the Internet if the attacker gags a host which is trusted by the target, impersonates the IP address and completes the three-way handshake based on its guess at the next initial sequence number to be used. See \href{https://tools.ietf.org/html/rfc1948}{RFC 1948} for more.
\end{Answer}

\begin{Exercise}
Which are the network protocols usually activated by a MUA such as \href{https://en.wikipedia.org/wiki/Mozilla_Thunderbird}{Thunderbird}?
What functionality is provided by each one of these protocols?
\end{Exercise}
\begin{Answer}
\begin{itemize}
    \item DNS, a protocol used to resolving names into IP addresses and other registered resources. For instance, to find out where to send gmail.com traffic.
    \item SMTP, a protocol used to send emails.
    \item POP3 and IMAP, protocols used for reading and deleting emails stored in a remote server.
\end{itemize}
\end{Answer}

\begin{Exercise}
An ISP allocated the 200.231.15.240 network with 16 IP addresses. What is the first and last valid addresses for network interfaces? What is the network mask? What is the broadcast address?
\end{Exercise}
\begin{Answer}
The first valid address is 200.231.15.241, and the last valid address is 200.231.15.254.
The network mask is 255.255.255.240. The broadcast address is 200.231.15.255.

One can test this by issuing \texttt{ipcalc 200.231.15.240/28}.
\end{Answer}

\begin{Exercise}
\end{Exercise}

\begin{Exercise}
\end{Exercise}

\subsection{Solved textbook exercises}
\setcounter{Exercise}{0}

\begin{Exercise}
Give two example computer applications for which connection-oriented service is appropriate.
Now give two examples for which connectionless service is best.
From \cite{computer-networks-tanenbaum-2012}.
\end{Exercise}
\begin{Answer}
File transfer, remote login, and video on demand need connection-oriented service.
On the other hand, credit card verification and other point-of-sale terminals, electronic funds transfer, and many forms of remote database access are inherently connectionless, with a query going one way and the reply coming back the other way.
\end{Answer}

\begin{Exercise}
Give three examples of protocol parameters that might be negotiated when a connection is set up.
From \cite{computer-networks-tanenbaum-2012}.
\end{Exercise}
\begin{Answer}
\begin{enumerate}
    \item Window size.
    \item Maximum packet size.
    \item Data rate.
\end{enumerate}
\end{Answer}

\begin{Exercise}
Assuming that all routers and hosts are working properly and that all software in both is free of all errors, is there any chance, however small, that a packet will be delivered to the wrong destination?
From \cite{computer-networks-tanenbaum-2012}.
\end{Exercise}
\begin{Answer}
Yes. A noise burst could drastically change a packet. With a \(k\)-bit checksum, there is a probability of \(2^{-k}\) that \textbf{the error is undetected}. If the destination field or, equivalently, virtual-circuit number, is changed, the packet will be delivered to the wrong destination and accepted as genuine. Put in other words, an occasional noise burst could change a perfectly legal packet for one destination into a perfectly legal packet for another destination.
\end{Answer}
