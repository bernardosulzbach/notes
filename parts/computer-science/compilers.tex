\chapter{Compilers}

\section{Libraries}

\subsection{Global offset table}

If the dynamic linker could only perform relocations, when the value of global symbol is required, the dynamic linker would have to look up the memory address of that symbol and rewrite the code to load that address \cite{computer-science-from-the-bottom-up}.

An enhancement would be to set aside space in the binary to hold the address of that symbol, and use the dynamic linker to put the address there rather than in the code directly.
This way the code of the binary would never have to be changed in runtime.
This area exists and is called the global offset table (GOT) \cite{computer-science-from-the-bottom-up}.

\subsection{Procedure lookup table}

The procedure lookup table (PLT) serves to facilitate \textit{lazy binding} in programs.
Binding is the name given to assigning an entry of the table the real address \cite{computer-science-from-the-bottom-up}.

Binding a function involves loading library code into memory if this hasn't been done yet, searching through it to find the function being called, and writing its real address to memory.
Therefore, binding unused functions is wasteful.
Each library function has an entry in the PLT, which initially points to a dummy function \cite{computer-science-from-the-bottom-up}.

When the program calls the function, it is actually calling the PLT entry.
This function loads a few parameters that are needed by the dynamic linker for it to resolve the function and then calls into a special lookup function of the dynamic linker.
The dynamic linker then changes the stub code so that the next time the function is called it will go straight to the right address \cite{computer-science-from-the-bottom-up}.

While the PLT is usually filled lazily in runtime, the GOT is filled before the program begins executing \cite{computer-science-from-the-bottom-up}.

\section{Code generation}

\subsection{Optimization of basic blocks}

\textbf{Local optimizations} are optimizations performed within a basic block.

A basic block can be represented as a directed acyclic graph (DAG).

\subsubsection{Local common subexpression elimination}

Local common subexpression elimination consists in eliminating expressions that compute a value that has already been computed \cite[p.~533]{compilers-aho-2007}.

For instance, in the following sequence of instructions, it would be interesting to compute the value of \texttt{b} and \texttt{d} only once.

\begin{lstlisting}
a = b + c
b = a - d
c = b + c
d = a - d
\end{lstlisting}

Note that in more elaborate examples, algebraic identities may need to be used before local common subexpression elimination can be applied.

\begin{lstlisting}
a = b + c
b = b - d
c = c + d
e = b + c
\end{lstlisting}

In the above example, even though \texttt{b} and \texttt{c} both change between the first and last statements, their sum remains the same.

\subsubsection{Dead code elimination}

Dead code elimination on DAG's correspond to removing roots (nodes with no ancestors) which have no live variables attached to it.

\subsubsection{Use of algebraic identities}

Algebraic identities represent another important class of optimization on basic blocks.

Algebraic identities can be used to remove \textbf{arithmetic identities} such as adding zero and multiplying by one \cite[p.~536]{compilers-aho-2007}.
\[x + 0 = 0 + x = x\]
\[x \cdot 1 = 1 \cdot x = x\]
They can also be used to perform \textbf{strength reduction}, that is, to replace more expensive operators by cheaper ones \cite[p.~536]{compilers-aho-2007}.
\[x^{2} = x \times x\]
\[x / 2 = x >> 1\]
A third class of algebraic identities is \textbf{constant folding}, in which constant expressions are evaluated at compile time \cite[p.~536]{compilers-aho-2007}.
\[2 * 32 = 64\]
Lastly, there are also more general algebraic transformations such as \textbf{commutativity and associativity} \cite[p.~536]{compilers-aho-2007}.

\begin{lstlisting}
a = b + c
t = c + d
e = t + b
\end{lstlisting}

In the listing above, if \texttt{t} is not needed afterwards, commutativity and associativity could be used to simplify the code to the following.

\begin{lstlisting}
a = b + c
e = a + d
\end{lstlisting}

\section{Machine independent optimization}

Soon.